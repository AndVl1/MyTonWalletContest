(self["webpackChunkmytonwallet"] = self["webpackChunkmytonwallet"] || []).push([["vendors-node_modules_ton_core_dist_boc_BitReader_js-node_modules_ton_core_dist_dict_Dictionar-9afbaa"],{

/***/ "./node_modules/@ton/core/dist/boc/BitReader.js":
/*!******************************************************!*\
  !*** ./node_modules/@ton/core/dist/boc/BitReader.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BitReader = void 0;
const Address_1 = __webpack_require__(/*! ../address/Address */ "./node_modules/@ton/core/dist/address/Address.js");
const ExternalAddress_1 = __webpack_require__(/*! ../address/ExternalAddress */ "./node_modules/@ton/core/dist/address/ExternalAddress.js");
/**
 * Class for reading bit strings
 */
class BitReader {
    constructor(bits, offset = 0) {
        this._checkpoints = [];
        this._bits = bits;
        this._offset = offset;
    }
    /**
     * Offset in source bit string
     */
    get offset() {
        return this._offset;
    }
    /**
     * Number of bits remaining
     */
    get remaining() {
        return this._bits.length - this._offset;
    }
    /**
     * Skip bits
     * @param bits number of bits to skip
     */
    skip(bits) {
        if (bits < 0 || this._offset + bits > this._bits.length) {
            throw new Error(`Index ${this._offset + bits} is out of bounds`);
        }
        this._offset += bits;
    }
    /**
     * Reset to the beginning or latest checkpoint
     */
    reset() {
        if (this._checkpoints.length > 0) {
            this._offset = this._checkpoints.pop();
        }
        else {
            this._offset = 0;
        }
    }
    /**
     * Save checkpoint
     */
    save() {
        this._checkpoints.push(this._offset);
    }
    /**
     * Load a single bit
     * @returns true if the bit is set, false otherwise
     */
    loadBit() {
        let r = this._bits.at(this._offset);
        this._offset++;
        return r;
    }
    /**
     * Preload bit
     * @returns true if the bit is set, false otherwise
     */
    preloadBit() {
        return this._bits.at(this._offset);
    }
    /**
     * Load bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    loadBits(bits) {
        let r = this._bits.substring(this._offset, bits);
        this._offset += bits;
        return r;
    }
    /**
     * Preload bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    preloadBits(bits) {
        return this._bits.substring(this._offset, bits);
    }
    /**
     * Load buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    loadBuffer(bytes) {
        let buf = this._preloadBuffer(bytes, this._offset);
        this._offset += bytes * 8;
        return buf;
    }
    /**
     * Preload buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    preloadBuffer(bytes) {
        return this._preloadBuffer(bytes, this._offset);
    }
    /**
     * Load uint value
     * @param bits uint bits
     * @returns read value as number
     */
    loadUint(bits) {
        return Number(this.loadUintBig(bits));
    }
    /**
     * Load uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    loadUintBig(bits) {
        let loaded = this.preloadUintBig(bits);
        this._offset += bits;
        return loaded;
    }
    /**
     * Preload uint value
     * @param bits uint bits
     * @returns read value as number
     */
    preloadUint(bits) {
        return Number(this._preloadUint(bits, this._offset));
    }
    /**
     * Preload uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    preloadUintBig(bits) {
        return this._preloadUint(bits, this._offset);
    }
    /**
     * Load int value
     * @param bits int bits
     * @returns read value as bigint
     */
    loadInt(bits) {
        let res = this._preloadInt(bits, this._offset);
        this._offset += bits;
        return Number(res);
    }
    /**
     * Load int value as bigint
     * @param bits int bits
     * @returns read value as bigint
     */
    loadIntBig(bits) {
        let res = this._preloadInt(bits, this._offset);
        this._offset += bits;
        return res;
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadInt(bits) {
        return Number(this._preloadInt(bits, this._offset));
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadIntBig(bits) {
        return this._preloadInt(bits, this._offset);
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUint(bits) {
        let size = Number(this.loadUint(bits));
        return Number(this.loadUintBig(size * 8));
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUintBig(bits) {
        let size = Number(this.loadUint(bits));
        return this.loadUintBig(size * 8);
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUint(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return Number(this._preloadUint(size * 8, this._offset + bits));
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUintBig(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return this._preloadUint(size * 8, this._offset + bits);
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarInt(bits) {
        let size = Number(this.loadUint(bits));
        return Number(this.loadIntBig(size * 8));
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarIntBig(bits) {
        let size = Number(this.loadUint(bits));
        return this.loadIntBig(size * 8);
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarInt(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return Number(this._preloadInt(size * 8, this._offset + bits));
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarIntBig(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return this._preloadInt(size * 8, this._offset + bits);
    }
    /**
     * Load coins value
     * @returns read value as bigint
     */
    loadCoins() {
        return this.loadVarUintBig(4);
    }
    /**
     * Preload coins value
     * @returns read value as bigint
     */
    preloadCoins() {
        return this.preloadVarUintBig(4);
    }
    /**
     * Load Address
     * @returns Address
     */
    loadAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 2) {
            return this._loadInternalAddress();
        }
        else {
            throw new Error("Invalid address: " + type);
        }
    }
    /**
     * Load internal address
     * @returns Address or null
     */
    loadMaybeAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
            this._offset += 2;
            return null;
        }
        else if (type === 2) {
            return this._loadInternalAddress();
        }
        else {
            throw new Error("Invalid address");
        }
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 1) {
            return this._loadExternalAddress();
        }
        else {
            throw new Error("Invalid address");
        }
    }
    /**
     * Load external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
            this._offset += 2;
            return null;
        }
        else if (type === 1) {
            return this._loadExternalAddress();
        }
        else {
            throw new Error("Invalid address");
        }
    }
    /**
     * Read address of any type
     * @returns Address or ExternalAddress or null
     */
    loadAddressAny() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
            this._offset += 2;
            return null;
        }
        else if (type === 2) {
            return this._loadInternalAddress();
        }
        else if (type === 1) {
            return this._loadExternalAddress();
        }
        else if (type === 3) {
            throw Error('Unsupported');
        }
        else {
            throw Error('Unreachable');
        }
    }
    /**
     * Load bit string that was padded to make it byte alligned. Used in BOC serialization
     * @param bytes number of bytes to read
     */
    loadPaddedBits(bits) {
        // Check that number of bits is byte alligned
        if (bits % 8 !== 0) {
            throw new Error("Invalid number of bits");
        }
        // Skip padding
        let length = bits;
        while (true) {
            if (this._bits.at(this._offset + length - 1)) {
                length--;
                break;
            }
            else {
                length--;
            }
        }
        // Read substring
        let r = this._bits.substring(this._offset, length);
        this._offset += bits;
        return r;
    }
    /**
     * Clone BitReader
     */
    clone() {
        return new BitReader(this._bits, this._offset);
    }
    /**
     * Preload int from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadInt(bits, offset) {
        if (bits == 0) {
            return 0n;
        }
        let sign = this._bits.at(offset);
        let res = 0n;
        for (let i = 0; i < bits - 1; i++) {
            if (this._bits.at(offset + 1 + i)) {
                res += 1n << BigInt(bits - i - 1 - 1);
            }
        }
        if (sign) {
            res = res - (1n << BigInt(bits - 1));
        }
        return res;
    }
    /**
     * Preload uint from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadUint(bits, offset) {
        if (bits == 0) {
            return 0n;
        }
        let res = 0n;
        for (let i = 0; i < bits; i++) {
            if (this._bits.at(offset + i)) {
                res += 1n << BigInt(bits - i - 1);
            }
        }
        return res;
    }
    _preloadBuffer(bytes, offset) {
        // Try to load fast
        let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
        if (fastBuffer) {
            return fastBuffer;
        }
        // Load slow
        let buf = Buffer.alloc(bytes);
        for (let i = 0; i < bytes; i++) {
            buf[i] = Number(this._preloadUint(8, offset + i * 8));
        }
        return buf;
    }
    _loadInternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type !== 2) {
            throw Error('Invalid address');
        }
        // No Anycast supported
        if (this._preloadUint(1, this._offset + 2) !== 0n) {
            throw Error('Invalid address');
        }
        // Read address
        let wc = Number(this._preloadInt(8, this._offset + 3));
        let hash = this._preloadBuffer(32, this._offset + 11);
        // Update offset
        this._offset += 267;
        return new Address_1.Address(wc, hash);
    }
    _loadExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type !== 1) {
            throw Error('Invalid address');
        }
        // Load length
        let bits = Number(this._preloadUint(9, this._offset + 2));
        // Load address
        let value = this._preloadUint(bits, this._offset + 11);
        // Update offset
        this._offset += 11 + bits;
        return new ExternalAddress_1.ExternalAddress(value, bits);
    }
}
exports.BitReader = BitReader;


/***/ }),

/***/ "./node_modules/@ton/core/dist/dict/Dictionary.js":
/*!********************************************************!*\
  !*** ./node_modules/@ton/core/dist/dict/Dictionary.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dictionary = void 0;
const Address_1 = __webpack_require__(/*! ../address/Address */ "./node_modules/@ton/core/dist/address/Address.js");
const Builder_1 = __webpack_require__(/*! ../boc/Builder */ "./node_modules/@ton/core/dist/boc/Builder.js");
const Cell_1 = __webpack_require__(/*! ../boc/Cell */ "./node_modules/@ton/core/dist/boc/Cell.js");
const BitString_1 = __webpack_require__(/*! ../boc/BitString */ "./node_modules/@ton/core/dist/boc/BitString.js");
const generateMerkleProof_1 = __webpack_require__(/*! ./generateMerkleProof */ "./node_modules/@ton/core/dist/dict/generateMerkleProof.js");
const generateMerkleUpdate_1 = __webpack_require__(/*! ./generateMerkleUpdate */ "./node_modules/@ton/core/dist/dict/generateMerkleUpdate.js");
const parseDict_1 = __webpack_require__(/*! ./parseDict */ "./node_modules/@ton/core/dist/dict/parseDict.js");
const serializeDict_1 = __webpack_require__(/*! ./serializeDict */ "./node_modules/@ton/core/dist/dict/serializeDict.js");
const internalKeySerializer_1 = __webpack_require__(/*! ./utils/internalKeySerializer */ "./node_modules/@ton/core/dist/dict/utils/internalKeySerializer.js");
class Dictionary {
    /**
     * Create an empty map
     * @param key key type
     * @param value value type
     * @returns Dictionary<K, V>
     */
    static empty(key, value) {
        if (key && value) {
            return new Dictionary(new Map(), key, value);
        }
        else {
            return new Dictionary(new Map(), null, null);
        }
    }
    /**
     * Load dictionary from slice
     * @param key key description
     * @param value value description
     * @param src slice
     * @returns Dictionary<K, V>
     */
    static load(key, value, sc) {
        let slice;
        if (sc instanceof Cell_1.Cell) {
            if (sc.isExotic) {
                return Dictionary.empty(key, value);
            }
            slice = sc.beginParse();
        }
        else {
            slice = sc;
        }
        let cell = slice.loadMaybeRef();
        if (cell && !cell.isExotic) {
            return Dictionary.loadDirect(key, value, cell.beginParse());
        }
        else {
            return Dictionary.empty(key, value);
        }
    }
    /**
     * Low level method for rare dictionaries from system contracts.
     * Loads dictionary from slice directly without going to the ref.
     *
     * @param key key description
     * @param value value description
     * @param sc slice
     * @returns Dictionary<K, V>
     */
    static loadDirect(key, value, sc) {
        if (!sc) {
            return Dictionary.empty(key, value);
        }
        let slice;
        if (sc instanceof Cell_1.Cell) {
            slice = sc.beginParse();
        }
        else {
            slice = sc;
        }
        let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);
        let prepare = new Map();
        for (let [k, v] of values) {
            prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k)), v);
        }
        return new Dictionary(prepare, key, value);
    }
    constructor(values, key, value) {
        this._key = key;
        this._value = value;
        this._map = values;
    }
    get size() {
        return this._map.size;
    }
    get(key) {
        return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));
    }
    has(key) {
        return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));
    }
    set(key, value) {
        this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);
        return this;
    }
    delete(key) {
        const k = (0, internalKeySerializer_1.serializeInternalKey)(key);
        return this._map.delete(k);
    }
    clear() {
        this._map.clear();
    }
    *[Symbol.iterator]() {
        for (const [k, v] of this._map) {
            const key = (0, internalKeySerializer_1.deserializeInternalKey)(k);
            yield [key, v];
        }
    }
    keys() {
        return Array.from(this._map.keys()).map((v) => (0, internalKeySerializer_1.deserializeInternalKey)(v));
    }
    values() {
        return Array.from(this._map.values());
    }
    store(builder, key, value) {
        if (this._map.size === 0) {
            builder.storeBit(0);
        }
        else {
            // Resolve serializer
            let resolvedKey = this._key;
            if (key !== null && key !== undefined) {
                resolvedKey = key;
            }
            let resolvedValue = this._value;
            if (value !== null && value !== undefined) {
                resolvedValue = value;
            }
            if (!resolvedKey) {
                throw Error('Key serializer is not defined');
            }
            if (!resolvedValue) {
                throw Error('Value serializer is not defined');
            }
            // Prepare map
            let prepared = new Map();
            for (const [k, v] of this._map) {
                prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
            }
            // Store
            builder.storeBit(1);
            let dd = (0, Builder_1.beginCell)();
            (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
            builder.storeRef(dd.endCell());
        }
    }
    storeDirect(builder, key, value) {
        if (this._map.size === 0) {
            throw Error('Cannot store empty dictionary directly');
        }
        // Resolve serializer
        let resolvedKey = this._key;
        if (key !== null && key !== undefined) {
            resolvedKey = key;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== undefined) {
            resolvedValue = value;
        }
        if (!resolvedKey) {
            throw Error('Key serializer is not defined');
        }
        if (!resolvedValue) {
            throw Error('Value serializer is not defined');
        }
        // Prepare map
        let prepared = new Map();
        for (const [k, v] of this._map) {
            prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
        }
        // Store
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder);
    }
    generateMerkleProof(key) {
        return (0, generateMerkleProof_1.generateMerkleProof)(this, key, this._key);
    }
    generateMerkleUpdate(key, newValue) {
        return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key, this._key, newValue);
    }
}
exports.Dictionary = Dictionary;
Dictionary.Keys = {
    /**
     * Standard address key
     * @returns DictionaryKey<Address>
     */
    Address: () => {
        return createAddressKey();
    },
    /**
     * Create standard big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigInt: (bits) => {
        return createBigIntKey(bits);
    },
    /**
     * Create integer key
     * @param bits bits of integer
     * @returns DictionaryKey<number>
     */
    Int: (bits) => {
        return createIntKey(bits);
    },
    /**
     * Create standard unsigned big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigUint: (bits) => {
        return createBigUintKey(bits);
    },
    /**
     * Create standard unsigned integer key
     * @param bits number of bits
     * @returns DictionaryKey<number>
     */
    Uint: (bits) => {
        return createUintKey(bits);
    },
    /**
     * Create standard buffer key
     * @param bytes number of bytes of a buffer
     * @returns DictionaryKey<Buffer>
     */
    Buffer: (bytes) => {
        return createBufferKey(bytes);
    },
    /**
     * Create BitString key
     * @param bits key length
     * @returns DictionaryKey<BitString>
     * Point is that Buffer has to be 8 bit aligned,
     * while key is TVM dictionary doesn't have to be
     * aligned at all.
     */
    BitString: (bits) => {
        return createBitStringKey(bits);
    }
};
Dictionary.Values = {
    /**
     * Create standard integer value
     * @returns DictionaryValue<bigint>
     */
    BigInt: (bits) => {
        return createBigIntValue(bits);
    },
    /**
     * Create standard integer value
     * @returns DictionaryValue<number>
     */
    Int: (bits) => {
        return createIntValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarInt: (bits) => {
        return createBigVarIntValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    BigUint: (bits) => {
        return createBigUintValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    Uint: (bits) => {
        return createUintValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarUint: (bits) => {
        return createBigVarUintValue(bits);
    },
    /**
     * Create standard boolean value
     * @returns DictionaryValue<boolean>
     */
    Bool: () => {
        return createBooleanValue();
    },
    /**
     * Create standard address value
     * @returns DictionaryValue<Address>
     */
    Address: () => {
        return createAddressValue();
    },
    /**
     * Create standard cell value
     * @returns DictionaryValue<Cell>
     */
    Cell: () => {
        return createCellValue();
    },
    /**
     * Create Builder value
     * @param bytes number of bytes of a buffer
     * @returns DictionaryValue<Builder>
     */
    Buffer: (bytes) => {
        return createBufferValue(bytes);
    },
    /**
     * Create BitString value
     * @param requested bit length
     * @returns DictionaryValue<BitString>
     * Point is that Buffer is not applicable
     * when length is not 8 bit alligned.
     */
    BitString: (bits) => {
        return createBitStringValue(bits);
    },
    /**
     * Create dictionary value
     * @param key
     * @param value
     */
    Dictionary: (key, value) => {
        return createDictionaryValue(key, value);
    }
};
//
// Keys and Values
//
function createAddressKey() {
    return {
        bits: 267,
        serialize: (src) => {
            if (!Address_1.Address.isAddress(src)) {
                throw Error('Key is not an address');
            }
            return (0, Builder_1.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);
        },
        parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();
        }
    };
}
function createBigIntKey(bits) {
    return {
        bits,
        serialize: (src) => {
            if (typeof src !== 'bigint') {
                throw Error('Key is not a bigint');
            }
            return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);
        }
    };
}
function createIntKey(bits) {
    return {
        bits: bits,
        serialize: (src) => {
            if (typeof src !== 'number') {
                throw Error('Key is not a number');
            }
            if (!Number.isSafeInteger(src)) {
                throw Error('Key is not a safe integer: ' + src);
            }
            return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);
        }
    };
}
function createBigUintKey(bits) {
    return {
        bits,
        serialize: (src) => {
            if (typeof src !== 'bigint') {
                throw Error('Key is not a bigint');
            }
            if (src < 0) {
                throw Error('Key is negative: ' + src);
            }
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        }
    };
}
function createUintKey(bits) {
    return {
        bits,
        serialize: (src) => {
            if (typeof src !== 'number') {
                throw Error('Key is not a number');
            }
            if (!Number.isSafeInteger(src)) {
                throw Error('Key is not a safe integer: ' + src);
            }
            if (src < 0) {
                throw Error('Key is negative: ' + src);
            }
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
            return Number((0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));
        }
    };
}
function createBufferKey(bytes) {
    return {
        bits: bytes * 8,
        serialize: (src) => {
            if (!Buffer.isBuffer(src)) {
                throw Error('Key is not a buffer');
            }
            return (0, Builder_1.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);
        },
        parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);
        }
    };
}
function createBitStringKey(bits) {
    return {
        bits,
        serialize: (src) => {
            if (!BitString_1.BitString.isBitString(src))
                throw Error('Key is not a BitString');
            return (0, Builder_1.beginCell)().storeBits(src).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadBits(bits);
        }
    };
}
function createIntValue(bits) {
    return {
        serialize: (src, buidler) => {
            buidler.storeInt(src, bits);
        },
        parse: (src) => {
            return src.loadInt(bits);
        }
    };
}
function createBigIntValue(bits) {
    return {
        serialize: (src, buidler) => {
            buidler.storeInt(src, bits);
        },
        parse: (src) => {
            return src.loadIntBig(bits);
        }
    };
}
function createBigVarIntValue(bits) {
    return {
        serialize: (src, buidler) => {
            buidler.storeVarInt(src, bits);
        },
        parse: (src) => {
            return src.loadVarIntBig(bits);
        }
    };
}
function createBigVarUintValue(bits) {
    return {
        serialize: (src, buidler) => {
            buidler.storeVarUint(src, bits);
        },
        parse: (src) => {
            return src.loadVarUintBig(bits);
        }
    };
}
function createUintValue(bits) {
    return {
        serialize: (src, buidler) => {
            buidler.storeUint(src, bits);
        },
        parse: (src) => {
            return src.loadUint(bits);
        }
    };
}
function createBigUintValue(bits) {
    return {
        serialize: (src, buidler) => {
            buidler.storeUint(src, bits);
        },
        parse: (src) => {
            return src.loadUintBig(bits);
        }
    };
}
function createBooleanValue() {
    return {
        serialize: (src, buidler) => {
            buidler.storeBit(src);
        },
        parse: (src) => {
            return src.loadBit();
        }
    };
}
function createAddressValue() {
    return {
        serialize: (src, buidler) => {
            buidler.storeAddress(src);
        },
        parse: (src) => {
            return src.loadAddress();
        }
    };
}
function createCellValue() {
    return {
        serialize: (src, buidler) => {
            buidler.storeRef(src);
        },
        parse: (src) => {
            return src.loadRef();
        }
    };
}
function createDictionaryValue(key, value) {
    return {
        serialize: (src, buidler) => {
            src.store(buidler);
        },
        parse: (src) => {
            return Dictionary.load(key, value, src);
        }
    };
}
function createBufferValue(size) {
    return {
        serialize: (src, buidler) => {
            if (src.length !== size) {
                throw Error('Invalid buffer size');
            }
            buidler.storeBuffer(src);
        },
        parse: (src) => {
            return src.loadBuffer(size);
        }
    };
}
function createBitStringValue(bits) {
    return {
        serialize: (src, builder) => {
            if (src.length !== bits) {
                throw Error('Invalid BitString size');
            }
            builder.storeBits(src);
        },
        parse: (src) => {
            return src.loadBits(bits);
        }
    };
}


/***/ }),

/***/ "./node_modules/@ton/core/dist/types/SendMode.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ton/core/dist/types/SendMode.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendMode = void 0;
var SendMode;
(function (SendMode) {
    SendMode[SendMode["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
    SendMode[SendMode["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
    SendMode[SendMode["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
    SendMode[SendMode["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
    SendMode[SendMode["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
    SendMode[SendMode["NONE"] = 0] = "NONE";
})(SendMode || (exports.SendMode = SendMode = {}));


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
__webpack_unused_export__ = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
__webpack_unused_export__ = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/tonapi-sdk-js/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/tonapi-sdk-js/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */
__webpack_unused_export__ = ({ value: true });
exports.Api = exports.HttpClient = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = void 0;
/** @example "active" */
var AccountStatus;
(function (AccountStatus) {
    AccountStatus["Nonexist"] = "nonexist";
    AccountStatus["Uninit"] = "uninit";
    AccountStatus["Active"] = "active";
    AccountStatus["Frozen"] = "frozen";
})(AccountStatus || (__webpack_unused_export__ = AccountStatus = {}));
/** @example "TransOrd" */
var TransactionType;
(function (TransactionType) {
    TransactionType["TransOrd"] = "TransOrd";
    TransactionType["TransTickTock"] = "TransTickTock";
    TransactionType["TransSplitPrepare"] = "TransSplitPrepare";
    TransactionType["TransSplitInstall"] = "TransSplitInstall";
    TransactionType["TransMergePrepare"] = "TransMergePrepare";
    TransactionType["TransMergeInstall"] = "TransMergeInstall";
    TransactionType["TransStorage"] = "TransStorage";
})(TransactionType || (__webpack_unused_export__ = TransactionType = {}));
/** @example "acst_unchanged" */
var AccStatusChange;
(function (AccStatusChange) {
    AccStatusChange["AcstUnchanged"] = "acst_unchanged";
    AccStatusChange["AcstFrozen"] = "acst_frozen";
    AccStatusChange["AcstDeleted"] = "acst_deleted";
})(AccStatusChange || (__webpack_unused_export__ = AccStatusChange = {}));
/** @example "cskip_no_state" */
var ComputeSkipReason;
(function (ComputeSkipReason) {
    ComputeSkipReason["CskipNoState"] = "cskip_no_state";
    ComputeSkipReason["CskipBadState"] = "cskip_bad_state";
    ComputeSkipReason["CskipNoGas"] = "cskip_no_gas";
})(ComputeSkipReason || (__webpack_unused_export__ = ComputeSkipReason = {}));
/** @example "cskip_no_state" */
var BouncePhaseType;
(function (BouncePhaseType) {
    BouncePhaseType["TrPhaseBounceNegfunds"] = "TrPhaseBounceNegfunds";
    BouncePhaseType["TrPhaseBounceNofunds"] = "TrPhaseBounceNofunds";
    BouncePhaseType["TrPhaseBounceOk"] = "TrPhaseBounceOk";
})(BouncePhaseType || (__webpack_unused_export__ = BouncePhaseType = {}));
var JettonVerificationType;
(function (JettonVerificationType) {
    JettonVerificationType["Whitelist"] = "whitelist";
    JettonVerificationType["Blacklist"] = "blacklist";
    JettonVerificationType["None"] = "none";
})(JettonVerificationType || (__webpack_unused_export__ = JettonVerificationType = {}));
/** @example "whitelist" */
var TrustType;
(function (TrustType) {
    TrustType["Whitelist"] = "whitelist";
    TrustType["Blacklist"] = "blacklist";
    TrustType["None"] = "none";
})(TrustType || (__webpack_unused_export__ = TrustType = {}));
var PoolImplementationType;
(function (PoolImplementationType) {
    PoolImplementationType["Whales"] = "whales";
    PoolImplementationType["Tf"] = "tf";
    PoolImplementationType["LiquidTF"] = "liquidTF";
})(PoolImplementationType || (__webpack_unused_export__ = PoolImplementationType = {}));
var ContentType;
(function (ContentType) {
    ContentType["Json"] = "application/json";
    ContentType["FormData"] = "multipart/form-data";
    ContentType["UrlEncoded"] = "application/x-www-form-urlencoded";
    ContentType["Text"] = "text/plain";
})(ContentType || (__webpack_unused_export__ = ContentType = {}));
class HttpClient {
    baseUrl = "https://tonapi.io";
    securityData = null;
    securityWorker;
    abortControllers = new Map();
    customFetch = (...fetchParams) => fetch(...fetchParams);
    baseApiParams = {
        credentials: "same-origin",
        headers: {},
        redirect: "follow",
        referrerPolicy: "no-referrer",
    };
    constructor(apiConfig = {}) {
        Object.assign(this, apiConfig);
    }
    setSecurityData = (data) => {
        this.securityData = data;
    };
    encodeQueryParam(key, value) {
        const encodedKey = encodeURIComponent(key);
        return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
    }
    addQueryParam(query, key) {
        return this.encodeQueryParam(key, query[key]);
    }
    addArrayQueryParam(query, key) {
        const value = query[key];
        return value.map((v) => this.encodeQueryParam(key, v)).join("&");
    }
    toQueryString(rawQuery) {
        const query = rawQuery || {};
        const keys = Object.keys(query).filter((key) => "undefined" !== typeof query[key]);
        return keys
            .map((key) => (Array.isArray(query[key]) ? this.addArrayQueryParam(query, key) : this.addQueryParam(query, key)))
            .join("&");
    }
    addQueryParams(rawQuery) {
        const queryString = this.toQueryString(rawQuery);
        return queryString ? `?${queryString}` : "";
    }
    contentFormatters = {
        [ContentType.Json]: (input) => input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
        [ContentType.Text]: (input) => (input !== null && typeof input !== "string" ? JSON.stringify(input) : input),
        [ContentType.FormData]: (input) => Object.keys(input || {}).reduce((formData, key) => {
            const property = input[key];
            formData.append(key, property instanceof Blob
                ? property
                : typeof property === "object" && property !== null
                    ? JSON.stringify(property)
                    : `${property}`);
            return formData;
        }, new FormData()),
        [ContentType.UrlEncoded]: (input) => this.toQueryString(input),
    };
    mergeRequestParams(params1, params2) {
        return {
            ...this.baseApiParams,
            ...params1,
            ...(params2 || {}),
            headers: {
                ...(this.baseApiParams.headers || {}),
                ...(params1.headers || {}),
                ...((params2 && params2.headers) || {}),
            },
        };
    }
    createAbortSignal = (cancelToken) => {
        if (this.abortControllers.has(cancelToken)) {
            const abortController = this.abortControllers.get(cancelToken);
            if (abortController) {
                return abortController.signal;
            }
            return void 0;
        }
        const abortController = new AbortController();
        this.abortControllers.set(cancelToken, abortController);
        return abortController.signal;
    };
    abortRequest = (cancelToken) => {
        const abortController = this.abortControllers.get(cancelToken);
        if (abortController) {
            abortController.abort();
            this.abortControllers.delete(cancelToken);
        }
    };
    request = async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }) => {
        const secureParams = ((typeof secure === "boolean" ? secure : this.baseApiParams.secure) &&
            this.securityWorker &&
            (await this.securityWorker(this.securityData))) ||
            {};
        const requestParams = this.mergeRequestParams(params, secureParams);
        const queryString = query && this.toQueryString(query);
        const payloadFormatter = this.contentFormatters[type || ContentType.Json];
        const responseFormat = format || requestParams.format;
        return this.customFetch(`${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`, {
            ...requestParams,
            headers: {
                ...(requestParams.headers || {}),
                ...(type && type !== ContentType.FormData ? { "Content-Type": type } : {}),
            },
            signal: (cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal) || null,
            body: typeof body === "undefined" || body === null ? null : payloadFormatter(body),
        }).then(async (response) => {
            const r = response;
            r.data = null;
            r.error = null;
            const data = !responseFormat
                ? r
                : await response[responseFormat]()
                    .then((data) => {
                    if (r.ok) {
                        r.data = data;
                    }
                    else {
                        r.error = data;
                    }
                    return r;
                })
                    .catch((e) => {
                    r.error = e;
                    return r;
                });
            if (cancelToken) {
                this.abortControllers.delete(cancelToken);
            }
            if (!response.ok)
                throw data;
            return data.data;
        });
    };
}
exports.HttpClient = HttpClient;
/**
 * @title REST api to TON blockchain explorer
 * @version 2.0.0
 * @baseUrl https://tonapi.io
 * @contact Support <support@tonkeeper.com>
 *
 * Provide access to indexed TON blockchain
 */
class Api {
    http;
    constructor(http) {
        this.http = http;
    }
    blockchain = {
        /**
         * @description Status
         *
         * @tags Blockchain
         * @name Status
         * @request GET:/v2/status
         */
        status: (params = {}) => this.http.request({
            path: `/v2/status`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get blockchain block data
         *
         * @tags Blockchain
         * @name GetBlockchainBlock
         * @request GET:/v2/blockchain/blocks/{block_id}
         */
        getBlockchainBlock: (blockId, params = {}) => this.http.request({
            path: `/v2/blockchain/blocks/${blockId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get blockchain block shards
         *
         * @tags Blockchain
         * @name GetBlockchainMasterchainShards
         * @request GET:/v2/blockchain/masterchain/{masterchain_seqno}/shards
         */
        getBlockchainMasterchainShards: (masterchainSeqno, params = {}) => this.http.request({
            path: `/v2/blockchain/masterchain/${masterchainSeqno}/shards`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get all blocks in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain.  We don't recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
         *
         * @tags Blockchain
         * @name GetBlockchainMasterchainBlocks
         * @request GET:/v2/blockchain/masterchain/{masterchain_seqno}/blocks
         */
        getBlockchainMasterchainBlocks: (masterchainSeqno, params = {}) => this.http.request({
            path: `/v2/blockchain/masterchain/${masterchainSeqno}/blocks`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get all transactions in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain. We don't recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
         *
         * @tags Blockchain
         * @name GetBlockchainMasterchainTransactions
         * @request GET:/v2/blockchain/masterchain/{masterchain_seqno}/transactions
         */
        getBlockchainMasterchainTransactions: (masterchainSeqno, params = {}) => this.http.request({
            path: `/v2/blockchain/masterchain/${masterchainSeqno}/transactions`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get blockchain config from a specific block, if present.
         *
         * @tags Blockchain
         * @name GetBlockchainConfigFromBlock
         * @request GET:/v2/blockchain/masterchain/{masterchain_seqno}/config
         */
        getBlockchainConfigFromBlock: (masterchainSeqno, params = {}) => this.http.request({
            path: `/v2/blockchain/masterchain/${masterchainSeqno}/config`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw blockchain config from a specific block, if present.
         *
         * @tags Blockchain
         * @name GetRawBlockchainConfigFromBlock
         * @request GET:/v2/blockchain/masterchain/{masterchain_seqno}/config/raw
         */
        getRawBlockchainConfigFromBlock: (masterchainSeqno, params = {}) => this.http.request({
            path: `/v2/blockchain/masterchain/${masterchainSeqno}/config/raw`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get transactions from block
         *
         * @tags Blockchain
         * @name GetBlockchainBlockTransactions
         * @request GET:/v2/blockchain/blocks/{block_id}/transactions
         */
        getBlockchainBlockTransactions: (blockId, params = {}) => this.http.request({
            path: `/v2/blockchain/blocks/${blockId}/transactions`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get transaction data
         *
         * @tags Blockchain
         * @name GetBlockchainTransaction
         * @request GET:/v2/blockchain/transactions/{transaction_id}
         */
        getBlockchainTransaction: (transactionId, params = {}) => this.http.request({
            path: `/v2/blockchain/transactions/${transactionId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get transaction data by message hash
         *
         * @tags Blockchain
         * @name GetBlockchainTransactionByMessageHash
         * @request GET:/v2/blockchain/messages/{msg_id}/transaction
         */
        getBlockchainTransactionByMessageHash: (msgId, params = {}) => this.http.request({
            path: `/v2/blockchain/messages/${msgId}/transaction`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get blockchain validators
         *
         * @tags Blockchain
         * @name GetBlockchainValidators
         * @request GET:/v2/blockchain/validators
         */
        getBlockchainValidators: (params = {}) => this.http.request({
            path: `/v2/blockchain/validators`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get last known masterchain block
         *
         * @tags Blockchain
         * @name GetBlockchainMasterchainHead
         * @request GET:/v2/blockchain/masterchain-head
         */
        getBlockchainMasterchainHead: (params = {}) => this.http.request({
            path: `/v2/blockchain/masterchain-head`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get low-level information about an account taken directly from the blockchain.
         *
         * @tags Blockchain
         * @name GetBlockchainRawAccount
         * @request GET:/v2/blockchain/accounts/{account_id}
         */
        getBlockchainRawAccount: (accountId, params = {}) => this.http.request({
            path: `/v2/blockchain/accounts/${accountId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get account transactions
         *
         * @tags Blockchain
         * @name GetBlockchainAccountTransactions
         * @request GET:/v2/blockchain/accounts/{account_id}/transactions
         */
        getBlockchainAccountTransactions: (accountId, query, params = {}) => this.http.request({
            path: `/v2/blockchain/accounts/${accountId}/transactions`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Execute get method for account
         *
         * @tags Blockchain
         * @name ExecGetMethodForBlockchainAccount
         * @request GET:/v2/blockchain/accounts/{account_id}/methods/{method_name}
         */
        execGetMethodForBlockchainAccount: (accountId, methodName, query, params = {}) => this.http.request({
            path: `/v2/blockchain/accounts/${accountId}/methods/${methodName}`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Send message to blockchain
         *
         * @tags Blockchain
         * @name SendBlockchainMessage
         * @request POST:/v2/blockchain/message
         */
        sendBlockchainMessage: (data, params = {}) => this.http.request({
            path: `/v2/blockchain/message`,
            method: "POST",
            body: data,
            ...params,
        }),
        /**
         * @description Get blockchain config
         *
         * @tags Blockchain
         * @name GetBlockchainConfig
         * @request GET:/v2/blockchain/config
         */
        getBlockchainConfig: (params = {}) => this.http.request({
            path: `/v2/blockchain/config`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw blockchain config
         *
         * @tags Blockchain
         * @name GetRawBlockchainConfig
         * @request GET:/v2/blockchain/config/raw
         */
        getRawBlockchainConfig: (params = {}) => this.http.request({
            path: `/v2/blockchain/config/raw`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Blockchain account inspect
         *
         * @tags Blockchain
         * @name BlockchainAccountInspect
         * @request GET:/v2/blockchain/accounts/{account_id}/inspect
         */
        blockchainAccountInspect: (accountId, params = {}) => this.http.request({
            path: `/v2/blockchain/accounts/${accountId}/inspect`,
            method: "GET",
            format: "json",
            ...params,
        }),
    };
    emulation = {
        /**
         * @description Decode a given message. Only external incoming messages can be decoded currently.
         *
         * @tags Emulation
         * @name DecodeMessage
         * @request POST:/v2/message/decode
         */
        decodeMessage: (data, params = {}) => this.http.request({
            path: `/v2/message/decode`,
            method: "POST",
            body: data,
            format: "json",
            ...params,
        }),
        /**
         * @description Emulate sending message to blockchain
         *
         * @tags Emulation
         * @name EmulateMessageToEvent
         * @request POST:/v2/events/emulate
         */
        emulateMessageToEvent: (data, query, params = {}) => this.http.request({
            path: `/v2/events/emulate`,
            method: "POST",
            query: query,
            body: data,
            format: "json",
            ...params,
        }),
        /**
         * @description Emulate sending message to blockchain
         *
         * @tags Emulation
         * @name EmulateMessageToTrace
         * @request POST:/v2/traces/emulate
         */
        emulateMessageToTrace: (data, query, params = {}) => this.http.request({
            path: `/v2/traces/emulate`,
            method: "POST",
            query: query,
            body: data,
            format: "json",
            ...params,
        }),
        /**
         * @description Emulate sending message to blockchain
         *
         * @tags Emulation
         * @name EmulateMessageToWallet
         * @request POST:/v2/wallet/emulate
         */
        emulateMessageToWallet: (data, params = {}) => this.http.request({
            path: `/v2/wallet/emulate`,
            method: "POST",
            body: data,
            format: "json",
            ...params,
        }),
        /**
         * @description Emulate sending message to blockchain
         *
         * @tags Emulation
         * @name EmulateMessageToAccountEvent
         * @request POST:/v2/accounts/{account_id}/events/emulate
         */
        emulateMessageToAccountEvent: (accountId, data, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/events/emulate`,
            method: "POST",
            query: query,
            body: data,
            format: "json",
            ...params,
        }),
    };
    accounts = {
        /**
         * @description parse address and display in all formats
         *
         * @tags Accounts
         * @name AddressParse
         * @request GET:/v2/address/{account_id}/parse
         */
        addressParse: (accountId, params = {}) => this.http.request({
            path: `/v2/address/${accountId}/parse`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get human-friendly information about several accounts without low-level details.
         *
         * @tags Accounts
         * @name GetAccounts
         * @request POST:/v2/accounts/_bulk
         */
        getAccounts: (data, params = {}) => this.http.request({
            path: `/v2/accounts/_bulk`,
            method: "POST",
            body: data,
            format: "json",
            ...params,
        }),
        /**
         * @description Get human-friendly information about an account without low-level details.
         *
         * @tags Accounts
         * @name GetAccount
         * @request GET:/v2/accounts/{account_id}
         */
        getAccount: (accountId, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get account's domains
         *
         * @tags Accounts
         * @name AccountDnsBackResolve
         * @request GET:/v2/accounts/{account_id}/dns/backresolve
         */
        accountDnsBackResolve: (accountId, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/dns/backresolve`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get all Jettons balances by owner address
         *
         * @tags Accounts
         * @name GetAccountJettonsBalances
         * @request GET:/v2/accounts/{account_id}/jettons
         */
        getAccountJettonsBalances: (accountId, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/jettons`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get the transfer jettons history for account
         *
         * @tags Accounts
         * @name GetAccountJettonsHistory
         * @request GET:/v2/accounts/{account_id}/jettons/history
         */
        getAccountJettonsHistory: (accountId, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/jettons/history`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get the transfer jetton history for account and jetton
         *
         * @tags Accounts
         * @name GetAccountJettonHistoryById
         * @request GET:/v2/accounts/{account_id}/jettons/{jetton_id}/history
         */
        getAccountJettonHistoryById: (accountId, jettonId, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/jettons/${jettonId}/history`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get all NFT items by owner address
         *
         * @tags Accounts
         * @name GetAccountNftItems
         * @request GET:/v2/accounts/{account_id}/nfts
         */
        getAccountNftItems: (accountId, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/nfts`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
         *
         * @tags Accounts
         * @name GetAccountEvents
         * @request GET:/v2/accounts/{account_id}/events
         */
        getAccountEvents: (accountId, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/events`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get event for an account by event_id
         *
         * @tags Accounts
         * @name GetAccountEvent
         * @request GET:/v2/accounts/{account_id}/events/{event_id}
         */
        getAccountEvent: (accountId, eventId, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/events/${eventId}`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get traces for account
         *
         * @tags Accounts
         * @name GetAccountTraces
         * @request GET:/v2/accounts/{account_id}/traces
         */
        getAccountTraces: (accountId, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/traces`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get all subscriptions by wallet address
         *
         * @tags Accounts
         * @name GetAccountSubscriptions
         * @request GET:/v2/accounts/{account_id}/subscriptions
         */
        getAccountSubscriptions: (accountId, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/subscriptions`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Update internal cache for a particular account
         *
         * @tags Accounts
         * @name ReindexAccount
         * @request POST:/v2/accounts/{account_id}/reindex
         */
        reindexAccount: (accountId, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/reindex`,
            method: "POST",
            ...params,
        }),
        /**
         * @description Search by account domain name
         *
         * @tags Accounts
         * @name SearchAccounts
         * @request GET:/v2/accounts/search
         */
        searchAccounts: (query, params = {}) => this.http.request({
            path: `/v2/accounts/search`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get expiring account .ton dns
         *
         * @tags Accounts
         * @name GetAccountDnsExpiring
         * @request GET:/v2/accounts/{account_id}/dns/expiring
         */
        getAccountDnsExpiring: (accountId, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/dns/expiring`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get public key by account id
         *
         * @tags Accounts
         * @name GetAccountPublicKey
         * @request GET:/v2/accounts/{account_id}/publickey
         */
        getAccountPublicKey: (accountId, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/publickey`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get account's balance change
         *
         * @tags Accounts
         * @name GetAccountDiff
         * @request GET:/v2/accounts/{account_id}/diff
         */
        getAccountDiff: (accountId, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/diff`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
    };
    nft = {
        /**
         * @description Get the transfer nft history
         *
         * @tags NFT
         * @name GetAccountNftHistory
         * @request GET:/v2/accounts/{account_id}/nfts/history
         */
        getAccountNftHistory: (accountId, query, params = {}) => this.http.request({
            path: `/v2/accounts/${accountId}/nfts/history`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get NFT collections
         *
         * @tags NFT
         * @name GetNftCollections
         * @request GET:/v2/nfts/collections
         */
        getNftCollections: (query, params = {}) => this.http.request({
            path: `/v2/nfts/collections`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get NFT collection by collection address
         *
         * @tags NFT
         * @name GetNftCollection
         * @request GET:/v2/nfts/collections/{account_id}
         */
        getNftCollection: (accountId, params = {}) => this.http.request({
            path: `/v2/nfts/collections/${accountId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get NFT items from collection by collection address
         *
         * @tags NFT
         * @name GetItemsFromCollection
         * @request GET:/v2/nfts/collections/{account_id}/items
         */
        getItemsFromCollection: (accountId, query, params = {}) => this.http.request({
            path: `/v2/nfts/collections/${accountId}/items`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get NFT items by their addresses
         *
         * @tags NFT
         * @name GetNftItemsByAddresses
         * @request POST:/v2/nfts/_bulk
         */
        getNftItemsByAddresses: (data, params = {}) => this.http.request({
            path: `/v2/nfts/_bulk`,
            method: "POST",
            body: data,
            format: "json",
            ...params,
        }),
        /**
         * @description Get NFT item by its address
         *
         * @tags NFT
         * @name GetNftItemByAddress
         * @request GET:/v2/nfts/{account_id}
         */
        getNftItemByAddress: (accountId, params = {}) => this.http.request({
            path: `/v2/nfts/${accountId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get the transfer nfts history for account
         *
         * @tags NFT
         * @name GetNftHistoryById
         * @request GET:/v2/nfts/{account_id}/history
         */
        getNftHistoryById: (accountId, query, params = {}) => this.http.request({
            path: `/v2/nfts/${accountId}/history`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
    };
    dns = {
        /**
         * @description Get full information about domain name
         *
         * @tags DNS
         * @name GetDnsInfo
         * @request GET:/v2/dns/{domain_name}
         */
        getDnsInfo: (domainName, params = {}) => this.http.request({
            path: `/v2/dns/${domainName}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description DNS resolve for domain name
         *
         * @tags DNS
         * @name DnsResolve
         * @request GET:/v2/dns/{domain_name}/resolve
         */
        dnsResolve: (domainName, params = {}) => this.http.request({
            path: `/v2/dns/${domainName}/resolve`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get domain bids
         *
         * @tags DNS
         * @name GetDomainBids
         * @request GET:/v2/dns/{domain_name}/bids
         */
        getDomainBids: (domainName, params = {}) => this.http.request({
            path: `/v2/dns/${domainName}/bids`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get all auctions
         *
         * @tags DNS
         * @name GetAllAuctions
         * @request GET:/v2/dns/auctions
         */
        getAllAuctions: (query, params = {}) => this.http.request({
            path: `/v2/dns/auctions`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
    };
    traces = {
        /**
         * @description Get the trace by trace ID or hash of any transaction in trace
         *
         * @tags Traces
         * @name GetTrace
         * @request GET:/v2/traces/{trace_id}
         */
        getTrace: (traceId, params = {}) => this.http.request({
            path: `/v2/traces/${traceId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
    };
    events = {
        /**
         * @description Get an event either by event ID or a hash of any transaction in a trace. An event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
         *
         * @tags Events
         * @name GetEvent
         * @request GET:/v2/events/{event_id}
         */
        getEvent: (eventId, params = {}) => this.http.request({
            path: `/v2/events/${eventId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
    };
    inscriptions = {
        /**
         * @description Get all inscriptions by owner address. It's experimental API and can be dropped in the future.
         *
         * @tags Inscriptions
         * @name GetAccountInscriptions
         * @request GET:/v2/experimental/accounts/{account_id}/inscriptions
         */
        getAccountInscriptions: (accountId, query, params = {}) => this.http.request({
            path: `/v2/experimental/accounts/${accountId}/inscriptions`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get the transfer inscriptions history for account. It's experimental API and can be dropped in the future.
         *
         * @tags Inscriptions
         * @name GetAccountInscriptionsHistory
         * @request GET:/v2/experimental/accounts/{account_id}/inscriptions/history
         */
        getAccountInscriptionsHistory: (accountId, query, params = {}) => this.http.request({
            path: `/v2/experimental/accounts/${accountId}/inscriptions/history`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get the transfer inscriptions history for account. It's experimental API and can be dropped in the future.
         *
         * @tags Inscriptions
         * @name GetAccountInscriptionsHistoryByTicker
         * @request GET:/v2/experimental/accounts/{account_id}/inscriptions/{ticker}/history
         */
        getAccountInscriptionsHistoryByTicker: (accountId, ticker, query, params = {}) => this.http.request({
            path: `/v2/experimental/accounts/${accountId}/inscriptions/${ticker}/history`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description return comment for making operation with inscription. please don't use it if you don't know what you are doing
         *
         * @tags Inscriptions
         * @name GetInscriptionOpTemplate
         * @request GET:/v2/experimental/inscriptions/op-template
         */
        getInscriptionOpTemplate: (query, params = {}) => this.http.request({
            path: `/v2/experimental/inscriptions/op-template`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
    };
    jettons = {
        /**
         * @description Get a list of all indexed jetton masters in the blockchain.
         *
         * @tags Jettons
         * @name GetJettons
         * @request GET:/v2/jettons
         */
        getJettons: (query, params = {}) => this.http.request({
            path: `/v2/jettons`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get jetton metadata by jetton master address
         *
         * @tags Jettons
         * @name GetJettonInfo
         * @request GET:/v2/jettons/{account_id}
         */
        getJettonInfo: (accountId, params = {}) => this.http.request({
            path: `/v2/jettons/${accountId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get jetton's holders
         *
         * @tags Jettons
         * @name GetJettonHolders
         * @request GET:/v2/jettons/{account_id}/holders
         */
        getJettonHolders: (accountId, query, params = {}) => this.http.request({
            path: `/v2/jettons/${accountId}/holders`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get only jetton transfers in the event
         *
         * @tags Jettons
         * @name GetJettonsEvents
         * @request GET:/v2/events/{event_id}/jettons
         */
        getJettonsEvents: (eventId, params = {}) => this.http.request({
            path: `/v2/events/${eventId}/jettons`,
            method: "GET",
            format: "json",
            ...params,
        }),
    };
    staking = {
        /**
         * @description All pools where account participates
         *
         * @tags Staking
         * @name GetAccountNominatorsPools
         * @request GET:/v2/staking/nominator/{account_id}/pools
         */
        getAccountNominatorsPools: (accountId, params = {}) => this.http.request({
            path: `/v2/staking/nominator/${accountId}/pools`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Stacking pool info
         *
         * @tags Staking
         * @name GetStakingPoolInfo
         * @request GET:/v2/staking/pool/{account_id}
         */
        getStakingPoolInfo: (accountId, params = {}) => this.http.request({
            path: `/v2/staking/pool/${accountId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Pool history
         *
         * @tags Staking
         * @name GetStakingPoolHistory
         * @request GET:/v2/staking/pool/{account_id}/history
         */
        getStakingPoolHistory: (accountId, params = {}) => this.http.request({
            path: `/v2/staking/pool/${accountId}/history`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description All pools available in network
         *
         * @tags Staking
         * @name GetStakingPools
         * @request GET:/v2/staking/pools
         */
        getStakingPools: (query, params = {}) => this.http.request({
            path: `/v2/staking/pools`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
    };
    storage = {
        /**
         * @description Get TON storage providers deployed to the blockchain.
         *
         * @tags Storage
         * @name GetStorageProviders
         * @request GET:/v2/storage/providers
         */
        getStorageProviders: (params = {}) => this.http.request({
            path: `/v2/storage/providers`,
            method: "GET",
            format: "json",
            ...params,
        }),
    };
    rates = {
        /**
         * @description Get the token price to the currency
         *
         * @tags Rates
         * @name GetRates
         * @request GET:/v2/rates
         */
        getRates: (query, params = {}) => this.http.request({
            path: `/v2/rates`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get chart by token
         *
         * @tags Rates
         * @name GetChartRates
         * @request GET:/v2/rates/chart
         */
        getChartRates: (query, params = {}) => this.http.request({
            path: `/v2/rates/chart`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get the TON price from markets
         *
         * @tags Rates
         * @name GetMarketsRates
         * @request GET:/v2/rates/markets
         */
        getMarketsRates: (params = {}) => this.http.request({
            path: `/v2/rates/markets`,
            method: "GET",
            format: "json",
            ...params,
        }),
    };
    connect = {
        /**
         * @description Get a payload for further token receipt
         *
         * @tags Connect
         * @name GetTonConnectPayload
         * @request GET:/v2/tonconnect/payload
         */
        getTonConnectPayload: (params = {}) => this.http.request({
            path: `/v2/tonconnect/payload`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get account info by state init
         *
         * @tags Connect
         * @name GetAccountInfoByStateInit
         * @request POST:/v2/tonconnect/stateinit
         */
        getAccountInfoByStateInit: (data, params = {}) => this.http.request({
            path: `/v2/tonconnect/stateinit`,
            method: "POST",
            body: data,
            format: "json",
            ...params,
        }),
    };
    wallet = {
        /**
         * @description Get backup info
         *
         * @tags Wallet
         * @name GetWalletBackup
         * @request GET:/v2/wallet/backup
         */
        getWalletBackup: (params = {}) => this.http.request({
            path: `/v2/wallet/backup`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Set backup info
         *
         * @tags Wallet
         * @name SetWalletBackup
         * @request PUT:/v2/wallet/backup
         */
        setWalletBackup: (data, params = {}) => this.http.request({
            path: `/v2/wallet/backup`,
            method: "PUT",
            body: data,
            ...params,
        }),
        /**
         * @description Account verification and token issuance
         *
         * @tags Wallet
         * @name TonConnectProof
         * @request POST:/v2/wallet/auth/proof
         */
        tonConnectProof: (data, params = {}) => this.http.request({
            path: `/v2/wallet/auth/proof`,
            method: "POST",
            body: data,
            format: "json",
            ...params,
        }),
        /**
         * @description Get wallets by public key
         *
         * @tags Wallet
         * @name GetWalletsByPublicKey
         * @request GET:/v2/pubkeys/{public_key}/wallets
         */
        getWalletsByPublicKey: (publicKey, params = {}) => this.http.request({
            path: `/v2/pubkeys/${publicKey}/wallets`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get account seqno
         *
         * @tags Wallet
         * @name GetAccountSeqno
         * @request GET:/v2/wallet/{account_id}/seqno
         */
        getAccountSeqno: (accountId, params = {}) => this.http.request({
            path: `/v2/wallet/${accountId}/seqno`,
            method: "GET",
            format: "json",
            ...params,
        }),
    };
    liteServer = {
        /**
         * @description Get raw masterchain info
         *
         * @tags Lite Server
         * @name GetRawMasterchainInfo
         * @request GET:/v2/liteserver/get_masterchain_info
         */
        getRawMasterchainInfo: (params = {}) => this.http.request({
            path: `/v2/liteserver/get_masterchain_info`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw masterchain info ext
         *
         * @tags Lite Server
         * @name GetRawMasterchainInfoExt
         * @request GET:/v2/liteserver/get_masterchain_info_ext
         */
        getRawMasterchainInfoExt: (query, params = {}) => this.http.request({
            path: `/v2/liteserver/get_masterchain_info_ext`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw time
         *
         * @tags Lite Server
         * @name GetRawTime
         * @request GET:/v2/liteserver/get_time
         */
        getRawTime: (params = {}) => this.http.request({
            path: `/v2/liteserver/get_time`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw blockchain block
         *
         * @tags Lite Server
         * @name GetRawBlockchainBlock
         * @request GET:/v2/liteserver/get_block/{block_id}
         */
        getRawBlockchainBlock: (blockId, params = {}) => this.http.request({
            path: `/v2/liteserver/get_block/${blockId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw blockchain block state
         *
         * @tags Lite Server
         * @name GetRawBlockchainBlockState
         * @request GET:/v2/liteserver/get_state/{block_id}
         */
        getRawBlockchainBlockState: (blockId, params = {}) => this.http.request({
            path: `/v2/liteserver/get_state/${blockId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw blockchain block header
         *
         * @tags Lite Server
         * @name GetRawBlockchainBlockHeader
         * @request GET:/v2/liteserver/get_block_header/{block_id}
         */
        getRawBlockchainBlockHeader: (blockId, query, params = {}) => this.http.request({
            path: `/v2/liteserver/get_block_header/${blockId}`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Send raw message to blockchain
         *
         * @tags Lite Server
         * @name SendRawMessage
         * @request POST:/v2/liteserver/send_message
         */
        sendRawMessage: (data, params = {}) => this.http.request({
            path: `/v2/liteserver/send_message`,
            method: "POST",
            body: data,
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw account state
         *
         * @tags Lite Server
         * @name GetRawAccountState
         * @request GET:/v2/liteserver/get_account_state/{account_id}
         */
        getRawAccountState: (accountId, query, params = {}) => this.http.request({
            path: `/v2/liteserver/get_account_state/${accountId}`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw shard info
         *
         * @tags Lite Server
         * @name GetRawShardInfo
         * @request GET:/v2/liteserver/get_shard_info/{block_id}
         */
        getRawShardInfo: (blockId, query, params = {}) => this.http.request({
            path: `/v2/liteserver/get_shard_info/${blockId}`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get all raw shards info
         *
         * @tags Lite Server
         * @name GetAllRawShardsInfo
         * @request GET:/v2/liteserver/get_all_shards_info/{block_id}
         */
        getAllRawShardsInfo: (blockId, params = {}) => this.http.request({
            path: `/v2/liteserver/get_all_shards_info/${blockId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw transactions
         *
         * @tags Lite Server
         * @name GetRawTransactions
         * @request GET:/v2/liteserver/get_transactions/{account_id}
         */
        getRawTransactions: (accountId, query, params = {}) => this.http.request({
            path: `/v2/liteserver/get_transactions/${accountId}`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw list block transactions
         *
         * @tags Lite Server
         * @name GetRawListBlockTransactions
         * @request GET:/v2/liteserver/list_block_transactions/{block_id}
         */
        getRawListBlockTransactions: (blockId, query, params = {}) => this.http.request({
            path: `/v2/liteserver/list_block_transactions/${blockId}`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw block proof
         *
         * @tags Lite Server
         * @name GetRawBlockProof
         * @request GET:/v2/liteserver/get_block_proof
         */
        getRawBlockProof: (query, params = {}) => this.http.request({
            path: `/v2/liteserver/get_block_proof`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw config
         *
         * @tags Lite Server
         * @name GetRawConfig
         * @request GET:/v2/liteserver/get_config_all/{block_id}
         */
        getRawConfig: (blockId, query, params = {}) => this.http.request({
            path: `/v2/liteserver/get_config_all/${blockId}`,
            method: "GET",
            query: query,
            format: "json",
            ...params,
        }),
        /**
         * @description Get raw shard block proof
         *
         * @tags Lite Server
         * @name GetRawShardBlockProof
         * @request GET:/v2/liteserver/get_shard_block_proof/{block_id}
         */
        getRawShardBlockProof: (blockId, params = {}) => this.http.request({
            path: `/v2/liteserver/get_shard_block_proof/${blockId}`,
            method: "GET",
            format: "json",
            ...params,
        }),
        /**
         * @description Get out msg queue sizes
         *
         * @tags Lite Server
         * @name GetOutMsgQueueSizes
         * @request GET:/v2/liteserver/get_out_msg_queue_sizes
         */
        getOutMsgQueueSizes: (params = {}) => this.http.request({
            path: `/v2/liteserver/get_out_msg_queue_sizes`,
            method: "GET",
            format: "json",
            ...params,
        }),
    };
}
exports.Api = Api;


/***/ }),

/***/ "./node_modules/tonweb-mnemonic/dist/web/index.js":
/*!********************************************************!*\
  !*** ./node_modules/tonweb-mnemonic/dist/web/index.js ***!
  \********************************************************/
/***/ ((module) => {

!function(e,r){ true?module.exports=r():0}(self,(function(){return(()=>{var e={780:(e,r,t)=>{!function(e){"use strict";var r=function(e){var r,t=new Float64Array(16);if(e)for(r=0;r<e.length;r++)t[r]=e[r];return t},a=function(){throw new Error("no PRNG")},n=new Uint8Array(16),o=new Uint8Array(32);o[0]=9;var i=r(),s=r([1]),l=r([56129,1]),c=r([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),u=r([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),h=r([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),f=r([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),d=r([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function p(e,r,t,a){e[r]=t>>24&255,e[r+1]=t>>16&255,e[r+2]=t>>8&255,e[r+3]=255&t,e[r+4]=a>>24&255,e[r+5]=a>>16&255,e[r+6]=a>>8&255,e[r+7]=255&a}function y(e,r,t,a,n){var o,i=0;for(o=0;o<n;o++)i|=e[r+o]^t[a+o];return(1&i-1>>>8)-1}function g(e,r,t,a){return y(e,r,t,a,16)}function m(e,r,t,a){return y(e,r,t,a,32)}function b(e,r,t,a){!function(e,r,t,a){for(var n,o=255&a[0]|(255&a[1])<<8|(255&a[2])<<16|(255&a[3])<<24,i=255&t[0]|(255&t[1])<<8|(255&t[2])<<16|(255&t[3])<<24,s=255&t[4]|(255&t[5])<<8|(255&t[6])<<16|(255&t[7])<<24,l=255&t[8]|(255&t[9])<<8|(255&t[10])<<16|(255&t[11])<<24,c=255&t[12]|(255&t[13])<<8|(255&t[14])<<16|(255&t[15])<<24,u=255&a[4]|(255&a[5])<<8|(255&a[6])<<16|(255&a[7])<<24,h=255&r[0]|(255&r[1])<<8|(255&r[2])<<16|(255&r[3])<<24,f=255&r[4]|(255&r[5])<<8|(255&r[6])<<16|(255&r[7])<<24,d=255&r[8]|(255&r[9])<<8|(255&r[10])<<16|(255&r[11])<<24,p=255&r[12]|(255&r[13])<<8|(255&r[14])<<16|(255&r[15])<<24,y=255&a[8]|(255&a[9])<<8|(255&a[10])<<16|(255&a[11])<<24,g=255&t[16]|(255&t[17])<<8|(255&t[18])<<16|(255&t[19])<<24,m=255&t[20]|(255&t[21])<<8|(255&t[22])<<16|(255&t[23])<<24,b=255&t[24]|(255&t[25])<<8|(255&t[26])<<16|(255&t[27])<<24,w=255&t[28]|(255&t[29])<<8|(255&t[30])<<16|(255&t[31])<<24,v=255&a[12]|(255&a[13])<<8|(255&a[14])<<16|(255&a[15])<<24,k=o,x=i,A=s,_=l,U=c,E=u,M=h,z=f,j=d,S=p,B=y,T=g,K=m,P=b,Y=w,q=v,L=0;L<20;L+=2)k^=(n=(K^=(n=(j^=(n=(U^=(n=k+K|0)<<7|n>>>25)+k|0)<<9|n>>>23)+U|0)<<13|n>>>19)+j|0)<<18|n>>>14,E^=(n=(x^=(n=(P^=(n=(S^=(n=E+x|0)<<7|n>>>25)+E|0)<<9|n>>>23)+S|0)<<13|n>>>19)+P|0)<<18|n>>>14,B^=(n=(M^=(n=(A^=(n=(Y^=(n=B+M|0)<<7|n>>>25)+B|0)<<9|n>>>23)+Y|0)<<13|n>>>19)+A|0)<<18|n>>>14,q^=(n=(T^=(n=(z^=(n=(_^=(n=q+T|0)<<7|n>>>25)+q|0)<<9|n>>>23)+_|0)<<13|n>>>19)+z|0)<<18|n>>>14,k^=(n=(_^=(n=(A^=(n=(x^=(n=k+_|0)<<7|n>>>25)+k|0)<<9|n>>>23)+x|0)<<13|n>>>19)+A|0)<<18|n>>>14,E^=(n=(U^=(n=(z^=(n=(M^=(n=E+U|0)<<7|n>>>25)+E|0)<<9|n>>>23)+M|0)<<13|n>>>19)+z|0)<<18|n>>>14,B^=(n=(S^=(n=(j^=(n=(T^=(n=B+S|0)<<7|n>>>25)+B|0)<<9|n>>>23)+T|0)<<13|n>>>19)+j|0)<<18|n>>>14,q^=(n=(Y^=(n=(P^=(n=(K^=(n=q+Y|0)<<7|n>>>25)+q|0)<<9|n>>>23)+K|0)<<13|n>>>19)+P|0)<<18|n>>>14;k=k+o|0,x=x+i|0,A=A+s|0,_=_+l|0,U=U+c|0,E=E+u|0,M=M+h|0,z=z+f|0,j=j+d|0,S=S+p|0,B=B+y|0,T=T+g|0,K=K+m|0,P=P+b|0,Y=Y+w|0,q=q+v|0,e[0]=k>>>0&255,e[1]=k>>>8&255,e[2]=k>>>16&255,e[3]=k>>>24&255,e[4]=x>>>0&255,e[5]=x>>>8&255,e[6]=x>>>16&255,e[7]=x>>>24&255,e[8]=A>>>0&255,e[9]=A>>>8&255,e[10]=A>>>16&255,e[11]=A>>>24&255,e[12]=_>>>0&255,e[13]=_>>>8&255,e[14]=_>>>16&255,e[15]=_>>>24&255,e[16]=U>>>0&255,e[17]=U>>>8&255,e[18]=U>>>16&255,e[19]=U>>>24&255,e[20]=E>>>0&255,e[21]=E>>>8&255,e[22]=E>>>16&255,e[23]=E>>>24&255,e[24]=M>>>0&255,e[25]=M>>>8&255,e[26]=M>>>16&255,e[27]=M>>>24&255,e[28]=z>>>0&255,e[29]=z>>>8&255,e[30]=z>>>16&255,e[31]=z>>>24&255,e[32]=j>>>0&255,e[33]=j>>>8&255,e[34]=j>>>16&255,e[35]=j>>>24&255,e[36]=S>>>0&255,e[37]=S>>>8&255,e[38]=S>>>16&255,e[39]=S>>>24&255,e[40]=B>>>0&255,e[41]=B>>>8&255,e[42]=B>>>16&255,e[43]=B>>>24&255,e[44]=T>>>0&255,e[45]=T>>>8&255,e[46]=T>>>16&255,e[47]=T>>>24&255,e[48]=K>>>0&255,e[49]=K>>>8&255,e[50]=K>>>16&255,e[51]=K>>>24&255,e[52]=P>>>0&255,e[53]=P>>>8&255,e[54]=P>>>16&255,e[55]=P>>>24&255,e[56]=Y>>>0&255,e[57]=Y>>>8&255,e[58]=Y>>>16&255,e[59]=Y>>>24&255,e[60]=q>>>0&255,e[61]=q>>>8&255,e[62]=q>>>16&255,e[63]=q>>>24&255}(e,r,t,a)}function w(e,r,t,a){!function(e,r,t,a){for(var n,o=255&a[0]|(255&a[1])<<8|(255&a[2])<<16|(255&a[3])<<24,i=255&t[0]|(255&t[1])<<8|(255&t[2])<<16|(255&t[3])<<24,s=255&t[4]|(255&t[5])<<8|(255&t[6])<<16|(255&t[7])<<24,l=255&t[8]|(255&t[9])<<8|(255&t[10])<<16|(255&t[11])<<24,c=255&t[12]|(255&t[13])<<8|(255&t[14])<<16|(255&t[15])<<24,u=255&a[4]|(255&a[5])<<8|(255&a[6])<<16|(255&a[7])<<24,h=255&r[0]|(255&r[1])<<8|(255&r[2])<<16|(255&r[3])<<24,f=255&r[4]|(255&r[5])<<8|(255&r[6])<<16|(255&r[7])<<24,d=255&r[8]|(255&r[9])<<8|(255&r[10])<<16|(255&r[11])<<24,p=255&r[12]|(255&r[13])<<8|(255&r[14])<<16|(255&r[15])<<24,y=255&a[8]|(255&a[9])<<8|(255&a[10])<<16|(255&a[11])<<24,g=255&t[16]|(255&t[17])<<8|(255&t[18])<<16|(255&t[19])<<24,m=255&t[20]|(255&t[21])<<8|(255&t[22])<<16|(255&t[23])<<24,b=255&t[24]|(255&t[25])<<8|(255&t[26])<<16|(255&t[27])<<24,w=255&t[28]|(255&t[29])<<8|(255&t[30])<<16|(255&t[31])<<24,v=255&a[12]|(255&a[13])<<8|(255&a[14])<<16|(255&a[15])<<24,k=0;k<20;k+=2)o^=(n=(m^=(n=(d^=(n=(c^=(n=o+m|0)<<7|n>>>25)+o|0)<<9|n>>>23)+c|0)<<13|n>>>19)+d|0)<<18|n>>>14,u^=(n=(i^=(n=(b^=(n=(p^=(n=u+i|0)<<7|n>>>25)+u|0)<<9|n>>>23)+p|0)<<13|n>>>19)+b|0)<<18|n>>>14,y^=(n=(h^=(n=(s^=(n=(w^=(n=y+h|0)<<7|n>>>25)+y|0)<<9|n>>>23)+w|0)<<13|n>>>19)+s|0)<<18|n>>>14,v^=(n=(g^=(n=(f^=(n=(l^=(n=v+g|0)<<7|n>>>25)+v|0)<<9|n>>>23)+l|0)<<13|n>>>19)+f|0)<<18|n>>>14,o^=(n=(l^=(n=(s^=(n=(i^=(n=o+l|0)<<7|n>>>25)+o|0)<<9|n>>>23)+i|0)<<13|n>>>19)+s|0)<<18|n>>>14,u^=(n=(c^=(n=(f^=(n=(h^=(n=u+c|0)<<7|n>>>25)+u|0)<<9|n>>>23)+h|0)<<13|n>>>19)+f|0)<<18|n>>>14,y^=(n=(p^=(n=(d^=(n=(g^=(n=y+p|0)<<7|n>>>25)+y|0)<<9|n>>>23)+g|0)<<13|n>>>19)+d|0)<<18|n>>>14,v^=(n=(w^=(n=(b^=(n=(m^=(n=v+w|0)<<7|n>>>25)+v|0)<<9|n>>>23)+m|0)<<13|n>>>19)+b|0)<<18|n>>>14;e[0]=o>>>0&255,e[1]=o>>>8&255,e[2]=o>>>16&255,e[3]=o>>>24&255,e[4]=u>>>0&255,e[5]=u>>>8&255,e[6]=u>>>16&255,e[7]=u>>>24&255,e[8]=y>>>0&255,e[9]=y>>>8&255,e[10]=y>>>16&255,e[11]=y>>>24&255,e[12]=v>>>0&255,e[13]=v>>>8&255,e[14]=v>>>16&255,e[15]=v>>>24&255,e[16]=h>>>0&255,e[17]=h>>>8&255,e[18]=h>>>16&255,e[19]=h>>>24&255,e[20]=f>>>0&255,e[21]=f>>>8&255,e[22]=f>>>16&255,e[23]=f>>>24&255,e[24]=d>>>0&255,e[25]=d>>>8&255,e[26]=d>>>16&255,e[27]=d>>>24&255,e[28]=p>>>0&255,e[29]=p>>>8&255,e[30]=p>>>16&255,e[31]=p>>>24&255}(e,r,t,a)}var v=new Uint8Array([101,120,112,97,110,100,32,51,50,45,98,121,116,101,32,107]);function k(e,r,t,a,n,o,i){var s,l,c=new Uint8Array(16),u=new Uint8Array(64);for(l=0;l<16;l++)c[l]=0;for(l=0;l<8;l++)c[l]=o[l];for(;n>=64;){for(b(u,c,i,v),l=0;l<64;l++)e[r+l]=t[a+l]^u[l];for(s=1,l=8;l<16;l++)s=s+(255&c[l])|0,c[l]=255&s,s>>>=8;n-=64,r+=64,a+=64}if(n>0)for(b(u,c,i,v),l=0;l<n;l++)e[r+l]=t[a+l]^u[l];return 0}function x(e,r,t,a,n){var o,i,s=new Uint8Array(16),l=new Uint8Array(64);for(i=0;i<16;i++)s[i]=0;for(i=0;i<8;i++)s[i]=a[i];for(;t>=64;){for(b(l,s,n,v),i=0;i<64;i++)e[r+i]=l[i];for(o=1,i=8;i<16;i++)o=o+(255&s[i])|0,s[i]=255&o,o>>>=8;t-=64,r+=64}if(t>0)for(b(l,s,n,v),i=0;i<t;i++)e[r+i]=l[i];return 0}function A(e,r,t,a,n){var o=new Uint8Array(32);w(o,a,n,v);for(var i=new Uint8Array(8),s=0;s<8;s++)i[s]=a[s+16];return x(e,r,t,i,o)}function _(e,r,t,a,n,o,i){var s=new Uint8Array(32);w(s,o,i,v);for(var l=new Uint8Array(8),c=0;c<8;c++)l[c]=o[c+16];return k(e,r,t,a,n,l,s)}var U=function(e){var r,t,a,n,o,i,s,l;this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.leftover=0,this.fin=0,r=255&e[0]|(255&e[1])<<8,this.r[0]=8191&r,t=255&e[2]|(255&e[3])<<8,this.r[1]=8191&(r>>>13|t<<3),a=255&e[4]|(255&e[5])<<8,this.r[2]=7939&(t>>>10|a<<6),n=255&e[6]|(255&e[7])<<8,this.r[3]=8191&(a>>>7|n<<9),o=255&e[8]|(255&e[9])<<8,this.r[4]=255&(n>>>4|o<<12),this.r[5]=o>>>1&8190,i=255&e[10]|(255&e[11])<<8,this.r[6]=8191&(o>>>14|i<<2),s=255&e[12]|(255&e[13])<<8,this.r[7]=8065&(i>>>11|s<<5),l=255&e[14]|(255&e[15])<<8,this.r[8]=8191&(s>>>8|l<<8),this.r[9]=l>>>5&127,this.pad[0]=255&e[16]|(255&e[17])<<8,this.pad[1]=255&e[18]|(255&e[19])<<8,this.pad[2]=255&e[20]|(255&e[21])<<8,this.pad[3]=255&e[22]|(255&e[23])<<8,this.pad[4]=255&e[24]|(255&e[25])<<8,this.pad[5]=255&e[26]|(255&e[27])<<8,this.pad[6]=255&e[28]|(255&e[29])<<8,this.pad[7]=255&e[30]|(255&e[31])<<8};function E(e,r,t,a,n,o){var i=new U(o);return i.update(t,a,n),i.finish(e,r),0}function M(e,r,t,a,n,o){var i=new Uint8Array(16);return E(i,0,t,a,n,o),g(e,r,i,0)}function z(e,r,t,a,n){var o;if(t<32)return-1;for(_(e,0,r,0,t,a,n),E(e,16,e,32,t-32,e),o=0;o<16;o++)e[o]=0;return 0}function j(e,r,t,a,n){var o,i=new Uint8Array(32);if(t<32)return-1;if(A(i,0,32,a,n),0!==M(r,16,r,32,t-32,i))return-1;for(_(e,0,r,0,t,a,n),o=0;o<32;o++)e[o]=0;return 0}function S(e,r){var t;for(t=0;t<16;t++)e[t]=0|r[t]}function B(e){var r,t,a=1;for(r=0;r<16;r++)t=e[r]+a+65535,a=Math.floor(t/65536),e[r]=t-65536*a;e[0]+=a-1+37*(a-1)}function T(e,r,t){for(var a,n=~(t-1),o=0;o<16;o++)a=n&(e[o]^r[o]),e[o]^=a,r[o]^=a}function K(e,t){var a,n,o,i=r(),s=r();for(a=0;a<16;a++)s[a]=t[a];for(B(s),B(s),B(s),n=0;n<2;n++){for(i[0]=s[0]-65517,a=1;a<15;a++)i[a]=s[a]-65535-(i[a-1]>>16&1),i[a-1]&=65535;i[15]=s[15]-32767-(i[14]>>16&1),o=i[15]>>16&1,i[14]&=65535,T(s,i,1-o)}for(a=0;a<16;a++)e[2*a]=255&s[a],e[2*a+1]=s[a]>>8}function P(e,r){var t=new Uint8Array(32),a=new Uint8Array(32);return K(t,e),K(a,r),m(t,0,a,0)}function Y(e){var r=new Uint8Array(32);return K(r,e),1&r[0]}function q(e,r){var t;for(t=0;t<16;t++)e[t]=r[2*t]+(r[2*t+1]<<8);e[15]&=32767}function L(e,r,t){for(var a=0;a<16;a++)e[a]=r[a]+t[a]}function O(e,r,t){for(var a=0;a<16;a++)e[a]=r[a]-t[a]}function R(e,r,t){var a,n,o=0,i=0,s=0,l=0,c=0,u=0,h=0,f=0,d=0,p=0,y=0,g=0,m=0,b=0,w=0,v=0,k=0,x=0,A=0,_=0,U=0,E=0,M=0,z=0,j=0,S=0,B=0,T=0,K=0,P=0,Y=0,q=t[0],L=t[1],O=t[2],R=t[3],N=t[4],C=t[5],F=t[6],I=t[7],Z=t[8],D=t[9],G=t[10],H=t[11],V=t[12],W=t[13],X=t[14],$=t[15];o+=(a=r[0])*q,i+=a*L,s+=a*O,l+=a*R,c+=a*N,u+=a*C,h+=a*F,f+=a*I,d+=a*Z,p+=a*D,y+=a*G,g+=a*H,m+=a*V,b+=a*W,w+=a*X,v+=a*$,i+=(a=r[1])*q,s+=a*L,l+=a*O,c+=a*R,u+=a*N,h+=a*C,f+=a*F,d+=a*I,p+=a*Z,y+=a*D,g+=a*G,m+=a*H,b+=a*V,w+=a*W,v+=a*X,k+=a*$,s+=(a=r[2])*q,l+=a*L,c+=a*O,u+=a*R,h+=a*N,f+=a*C,d+=a*F,p+=a*I,y+=a*Z,g+=a*D,m+=a*G,b+=a*H,w+=a*V,v+=a*W,k+=a*X,x+=a*$,l+=(a=r[3])*q,c+=a*L,u+=a*O,h+=a*R,f+=a*N,d+=a*C,p+=a*F,y+=a*I,g+=a*Z,m+=a*D,b+=a*G,w+=a*H,v+=a*V,k+=a*W,x+=a*X,A+=a*$,c+=(a=r[4])*q,u+=a*L,h+=a*O,f+=a*R,d+=a*N,p+=a*C,y+=a*F,g+=a*I,m+=a*Z,b+=a*D,w+=a*G,v+=a*H,k+=a*V,x+=a*W,A+=a*X,_+=a*$,u+=(a=r[5])*q,h+=a*L,f+=a*O,d+=a*R,p+=a*N,y+=a*C,g+=a*F,m+=a*I,b+=a*Z,w+=a*D,v+=a*G,k+=a*H,x+=a*V,A+=a*W,_+=a*X,U+=a*$,h+=(a=r[6])*q,f+=a*L,d+=a*O,p+=a*R,y+=a*N,g+=a*C,m+=a*F,b+=a*I,w+=a*Z,v+=a*D,k+=a*G,x+=a*H,A+=a*V,_+=a*W,U+=a*X,E+=a*$,f+=(a=r[7])*q,d+=a*L,p+=a*O,y+=a*R,g+=a*N,m+=a*C,b+=a*F,w+=a*I,v+=a*Z,k+=a*D,x+=a*G,A+=a*H,_+=a*V,U+=a*W,E+=a*X,M+=a*$,d+=(a=r[8])*q,p+=a*L,y+=a*O,g+=a*R,m+=a*N,b+=a*C,w+=a*F,v+=a*I,k+=a*Z,x+=a*D,A+=a*G,_+=a*H,U+=a*V,E+=a*W,M+=a*X,z+=a*$,p+=(a=r[9])*q,y+=a*L,g+=a*O,m+=a*R,b+=a*N,w+=a*C,v+=a*F,k+=a*I,x+=a*Z,A+=a*D,_+=a*G,U+=a*H,E+=a*V,M+=a*W,z+=a*X,j+=a*$,y+=(a=r[10])*q,g+=a*L,m+=a*O,b+=a*R,w+=a*N,v+=a*C,k+=a*F,x+=a*I,A+=a*Z,_+=a*D,U+=a*G,E+=a*H,M+=a*V,z+=a*W,j+=a*X,S+=a*$,g+=(a=r[11])*q,m+=a*L,b+=a*O,w+=a*R,v+=a*N,k+=a*C,x+=a*F,A+=a*I,_+=a*Z,U+=a*D,E+=a*G,M+=a*H,z+=a*V,j+=a*W,S+=a*X,B+=a*$,m+=(a=r[12])*q,b+=a*L,w+=a*O,v+=a*R,k+=a*N,x+=a*C,A+=a*F,_+=a*I,U+=a*Z,E+=a*D,M+=a*G,z+=a*H,j+=a*V,S+=a*W,B+=a*X,T+=a*$,b+=(a=r[13])*q,w+=a*L,v+=a*O,k+=a*R,x+=a*N,A+=a*C,_+=a*F,U+=a*I,E+=a*Z,M+=a*D,z+=a*G,j+=a*H,S+=a*V,B+=a*W,T+=a*X,K+=a*$,w+=(a=r[14])*q,v+=a*L,k+=a*O,x+=a*R,A+=a*N,_+=a*C,U+=a*F,E+=a*I,M+=a*Z,z+=a*D,j+=a*G,S+=a*H,B+=a*V,T+=a*W,K+=a*X,P+=a*$,v+=(a=r[15])*q,i+=38*(x+=a*O),s+=38*(A+=a*R),l+=38*(_+=a*N),c+=38*(U+=a*C),u+=38*(E+=a*F),h+=38*(M+=a*I),f+=38*(z+=a*Z),d+=38*(j+=a*D),p+=38*(S+=a*G),y+=38*(B+=a*H),g+=38*(T+=a*V),m+=38*(K+=a*W),b+=38*(P+=a*X),w+=38*(Y+=a*$),o=(a=(o+=38*(k+=a*L))+(n=1)+65535)-65536*(n=Math.floor(a/65536)),i=(a=i+n+65535)-65536*(n=Math.floor(a/65536)),s=(a=s+n+65535)-65536*(n=Math.floor(a/65536)),l=(a=l+n+65535)-65536*(n=Math.floor(a/65536)),c=(a=c+n+65535)-65536*(n=Math.floor(a/65536)),u=(a=u+n+65535)-65536*(n=Math.floor(a/65536)),h=(a=h+n+65535)-65536*(n=Math.floor(a/65536)),f=(a=f+n+65535)-65536*(n=Math.floor(a/65536)),d=(a=d+n+65535)-65536*(n=Math.floor(a/65536)),p=(a=p+n+65535)-65536*(n=Math.floor(a/65536)),y=(a=y+n+65535)-65536*(n=Math.floor(a/65536)),g=(a=g+n+65535)-65536*(n=Math.floor(a/65536)),m=(a=m+n+65535)-65536*(n=Math.floor(a/65536)),b=(a=b+n+65535)-65536*(n=Math.floor(a/65536)),w=(a=w+n+65535)-65536*(n=Math.floor(a/65536)),v=(a=v+n+65535)-65536*(n=Math.floor(a/65536)),o=(a=(o+=n-1+37*(n-1))+(n=1)+65535)-65536*(n=Math.floor(a/65536)),i=(a=i+n+65535)-65536*(n=Math.floor(a/65536)),s=(a=s+n+65535)-65536*(n=Math.floor(a/65536)),l=(a=l+n+65535)-65536*(n=Math.floor(a/65536)),c=(a=c+n+65535)-65536*(n=Math.floor(a/65536)),u=(a=u+n+65535)-65536*(n=Math.floor(a/65536)),h=(a=h+n+65535)-65536*(n=Math.floor(a/65536)),f=(a=f+n+65535)-65536*(n=Math.floor(a/65536)),d=(a=d+n+65535)-65536*(n=Math.floor(a/65536)),p=(a=p+n+65535)-65536*(n=Math.floor(a/65536)),y=(a=y+n+65535)-65536*(n=Math.floor(a/65536)),g=(a=g+n+65535)-65536*(n=Math.floor(a/65536)),m=(a=m+n+65535)-65536*(n=Math.floor(a/65536)),b=(a=b+n+65535)-65536*(n=Math.floor(a/65536)),w=(a=w+n+65535)-65536*(n=Math.floor(a/65536)),v=(a=v+n+65535)-65536*(n=Math.floor(a/65536)),o+=n-1+37*(n-1),e[0]=o,e[1]=i,e[2]=s,e[3]=l,e[4]=c,e[5]=u,e[6]=h,e[7]=f,e[8]=d,e[9]=p,e[10]=y,e[11]=g,e[12]=m,e[13]=b,e[14]=w,e[15]=v}function N(e,r){R(e,r,r)}function C(e,t){var a,n=r();for(a=0;a<16;a++)n[a]=t[a];for(a=253;a>=0;a--)N(n,n),2!==a&&4!==a&&R(n,n,t);for(a=0;a<16;a++)e[a]=n[a]}function F(e,t){var a,n=r();for(a=0;a<16;a++)n[a]=t[a];for(a=250;a>=0;a--)N(n,n),1!==a&&R(n,n,t);for(a=0;a<16;a++)e[a]=n[a]}function I(e,t,a){var n,o,i=new Uint8Array(32),s=new Float64Array(80),c=r(),u=r(),h=r(),f=r(),d=r(),p=r();for(o=0;o<31;o++)i[o]=t[o];for(i[31]=127&t[31]|64,i[0]&=248,q(s,a),o=0;o<16;o++)u[o]=s[o],f[o]=c[o]=h[o]=0;for(c[0]=f[0]=1,o=254;o>=0;--o)T(c,u,n=i[o>>>3]>>>(7&o)&1),T(h,f,n),L(d,c,h),O(c,c,h),L(h,u,f),O(u,u,f),N(f,d),N(p,c),R(c,h,c),R(h,u,d),L(d,c,h),O(c,c,h),N(u,c),O(h,f,p),R(c,h,l),L(c,c,f),R(h,h,c),R(c,f,p),R(f,u,s),N(u,d),T(c,u,n),T(h,f,n);for(o=0;o<16;o++)s[o+16]=c[o],s[o+32]=h[o],s[o+48]=u[o],s[o+64]=f[o];var y=s.subarray(32),g=s.subarray(16);return C(y,y),R(g,g,y),K(e,g),0}function Z(e,r){return I(e,r,o)}function D(e,r){return a(r,32),Z(e,r)}function G(e,r,t){var a=new Uint8Array(32);return I(a,t,r),w(e,n,a,v)}U.prototype.blocks=function(e,r,t){for(var a,n,o,i,s,l,c,u,h,f,d,p,y,g,m,b,w,v,k,x=this.fin?0:2048,A=this.h[0],_=this.h[1],U=this.h[2],E=this.h[3],M=this.h[4],z=this.h[5],j=this.h[6],S=this.h[7],B=this.h[8],T=this.h[9],K=this.r[0],P=this.r[1],Y=this.r[2],q=this.r[3],L=this.r[4],O=this.r[5],R=this.r[6],N=this.r[7],C=this.r[8],F=this.r[9];t>=16;)f=h=0,f+=(A+=8191&(a=255&e[r+0]|(255&e[r+1])<<8))*K,f+=(_+=8191&(a>>>13|(n=255&e[r+2]|(255&e[r+3])<<8)<<3))*(5*F),f+=(U+=8191&(n>>>10|(o=255&e[r+4]|(255&e[r+5])<<8)<<6))*(5*C),f+=(E+=8191&(o>>>7|(i=255&e[r+6]|(255&e[r+7])<<8)<<9))*(5*N),h=(f+=(M+=8191&(i>>>4|(s=255&e[r+8]|(255&e[r+9])<<8)<<12))*(5*R))>>>13,f&=8191,f+=(z+=s>>>1&8191)*(5*O),f+=(j+=8191&(s>>>14|(l=255&e[r+10]|(255&e[r+11])<<8)<<2))*(5*L),f+=(S+=8191&(l>>>11|(c=255&e[r+12]|(255&e[r+13])<<8)<<5))*(5*q),f+=(B+=8191&(c>>>8|(u=255&e[r+14]|(255&e[r+15])<<8)<<8))*(5*Y),d=h+=(f+=(T+=u>>>5|x)*(5*P))>>>13,d+=A*P,d+=_*K,d+=U*(5*F),d+=E*(5*C),h=(d+=M*(5*N))>>>13,d&=8191,d+=z*(5*R),d+=j*(5*O),d+=S*(5*L),d+=B*(5*q),h+=(d+=T*(5*Y))>>>13,d&=8191,p=h,p+=A*Y,p+=_*P,p+=U*K,p+=E*(5*F),h=(p+=M*(5*C))>>>13,p&=8191,p+=z*(5*N),p+=j*(5*R),p+=S*(5*O),p+=B*(5*L),y=h+=(p+=T*(5*q))>>>13,y+=A*q,y+=_*Y,y+=U*P,y+=E*K,h=(y+=M*(5*F))>>>13,y&=8191,y+=z*(5*C),y+=j*(5*N),y+=S*(5*R),y+=B*(5*O),g=h+=(y+=T*(5*L))>>>13,g+=A*L,g+=_*q,g+=U*Y,g+=E*P,h=(g+=M*K)>>>13,g&=8191,g+=z*(5*F),g+=j*(5*C),g+=S*(5*N),g+=B*(5*R),m=h+=(g+=T*(5*O))>>>13,m+=A*O,m+=_*L,m+=U*q,m+=E*Y,h=(m+=M*P)>>>13,m&=8191,m+=z*K,m+=j*(5*F),m+=S*(5*C),m+=B*(5*N),b=h+=(m+=T*(5*R))>>>13,b+=A*R,b+=_*O,b+=U*L,b+=E*q,h=(b+=M*Y)>>>13,b&=8191,b+=z*P,b+=j*K,b+=S*(5*F),b+=B*(5*C),w=h+=(b+=T*(5*N))>>>13,w+=A*N,w+=_*R,w+=U*O,w+=E*L,h=(w+=M*q)>>>13,w&=8191,w+=z*Y,w+=j*P,w+=S*K,w+=B*(5*F),v=h+=(w+=T*(5*C))>>>13,v+=A*C,v+=_*N,v+=U*R,v+=E*O,h=(v+=M*L)>>>13,v&=8191,v+=z*q,v+=j*Y,v+=S*P,v+=B*K,k=h+=(v+=T*(5*F))>>>13,k+=A*F,k+=_*C,k+=U*N,k+=E*R,h=(k+=M*O)>>>13,k&=8191,k+=z*L,k+=j*q,k+=S*Y,k+=B*P,A=f=8191&(h=(h=((h+=(k+=T*K)>>>13)<<2)+h|0)+(f&=8191)|0),_=d+=h>>>=13,U=p&=8191,E=y&=8191,M=g&=8191,z=m&=8191,j=b&=8191,S=w&=8191,B=v&=8191,T=k&=8191,r+=16,t-=16;this.h[0]=A,this.h[1]=_,this.h[2]=U,this.h[3]=E,this.h[4]=M,this.h[5]=z,this.h[6]=j,this.h[7]=S,this.h[8]=B,this.h[9]=T},U.prototype.finish=function(e,r){var t,a,n,o,i=new Uint16Array(10);if(this.leftover){for(o=this.leftover,this.buffer[o++]=1;o<16;o++)this.buffer[o]=0;this.fin=1,this.blocks(this.buffer,0,16)}for(t=this.h[1]>>>13,this.h[1]&=8191,o=2;o<10;o++)this.h[o]+=t,t=this.h[o]>>>13,this.h[o]&=8191;for(this.h[0]+=5*t,t=this.h[0]>>>13,this.h[0]&=8191,this.h[1]+=t,t=this.h[1]>>>13,this.h[1]&=8191,this.h[2]+=t,i[0]=this.h[0]+5,t=i[0]>>>13,i[0]&=8191,o=1;o<10;o++)i[o]=this.h[o]+t,t=i[o]>>>13,i[o]&=8191;for(i[9]-=8192,a=(1^t)-1,o=0;o<10;o++)i[o]&=a;for(a=~a,o=0;o<10;o++)this.h[o]=this.h[o]&a|i[o];for(this.h[0]=65535&(this.h[0]|this.h[1]<<13),this.h[1]=65535&(this.h[1]>>>3|this.h[2]<<10),this.h[2]=65535&(this.h[2]>>>6|this.h[3]<<7),this.h[3]=65535&(this.h[3]>>>9|this.h[4]<<4),this.h[4]=65535&(this.h[4]>>>12|this.h[5]<<1|this.h[6]<<14),this.h[5]=65535&(this.h[6]>>>2|this.h[7]<<11),this.h[6]=65535&(this.h[7]>>>5|this.h[8]<<8),this.h[7]=65535&(this.h[8]>>>8|this.h[9]<<5),n=this.h[0]+this.pad[0],this.h[0]=65535&n,o=1;o<8;o++)n=(this.h[o]+this.pad[o]|0)+(n>>>16)|0,this.h[o]=65535&n;e[r+0]=this.h[0]>>>0&255,e[r+1]=this.h[0]>>>8&255,e[r+2]=this.h[1]>>>0&255,e[r+3]=this.h[1]>>>8&255,e[r+4]=this.h[2]>>>0&255,e[r+5]=this.h[2]>>>8&255,e[r+6]=this.h[3]>>>0&255,e[r+7]=this.h[3]>>>8&255,e[r+8]=this.h[4]>>>0&255,e[r+9]=this.h[4]>>>8&255,e[r+10]=this.h[5]>>>0&255,e[r+11]=this.h[5]>>>8&255,e[r+12]=this.h[6]>>>0&255,e[r+13]=this.h[6]>>>8&255,e[r+14]=this.h[7]>>>0&255,e[r+15]=this.h[7]>>>8&255},U.prototype.update=function(e,r,t){var a,n;if(this.leftover){for((n=16-this.leftover)>t&&(n=t),a=0;a<n;a++)this.buffer[this.leftover+a]=e[r+a];if(t-=n,r+=n,this.leftover+=n,this.leftover<16)return;this.blocks(this.buffer,0,16),this.leftover=0}if(t>=16&&(n=t-t%16,this.blocks(e,r,n),r+=n,t-=n),t){for(a=0;a<t;a++)this.buffer[this.leftover+a]=e[r+a];this.leftover+=t}};var H=z,V=j,W=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function X(e,r,t,a){for(var n,o,i,s,l,c,u,h,f,d,p,y,g,m,b,w,v,k,x,A,_,U,E,M,z,j,S=new Int32Array(16),B=new Int32Array(16),T=e[0],K=e[1],P=e[2],Y=e[3],q=e[4],L=e[5],O=e[6],R=e[7],N=r[0],C=r[1],F=r[2],I=r[3],Z=r[4],D=r[5],G=r[6],H=r[7],V=0;a>=128;){for(x=0;x<16;x++)A=8*x+V,S[x]=t[A+0]<<24|t[A+1]<<16|t[A+2]<<8|t[A+3],B[x]=t[A+4]<<24|t[A+5]<<16|t[A+6]<<8|t[A+7];for(x=0;x<80;x++)if(n=T,o=K,i=P,s=Y,l=q,c=L,u=O,f=N,d=C,p=F,y=I,g=Z,m=D,b=G,E=65535&(U=H),M=U>>>16,z=65535&(_=R),j=_>>>16,E+=65535&(U=(Z>>>14|q<<18)^(Z>>>18|q<<14)^(q>>>9|Z<<23)),M+=U>>>16,z+=65535&(_=(q>>>14|Z<<18)^(q>>>18|Z<<14)^(Z>>>9|q<<23)),j+=_>>>16,E+=65535&(U=Z&D^~Z&G),M+=U>>>16,z+=65535&(_=q&L^~q&O),j+=_>>>16,E+=65535&(U=W[2*x+1]),M+=U>>>16,z+=65535&(_=W[2*x]),j+=_>>>16,_=S[x%16],M+=(U=B[x%16])>>>16,z+=65535&_,j+=_>>>16,z+=(M+=(E+=65535&U)>>>16)>>>16,E=65535&(U=k=65535&E|M<<16),M=U>>>16,z=65535&(_=v=65535&z|(j+=z>>>16)<<16),j=_>>>16,E+=65535&(U=(N>>>28|T<<4)^(T>>>2|N<<30)^(T>>>7|N<<25)),M+=U>>>16,z+=65535&(_=(T>>>28|N<<4)^(N>>>2|T<<30)^(N>>>7|T<<25)),j+=_>>>16,M+=(U=N&C^N&F^C&F)>>>16,z+=65535&(_=T&K^T&P^K&P),j+=_>>>16,h=65535&(z+=(M+=(E+=65535&U)>>>16)>>>16)|(j+=z>>>16)<<16,w=65535&E|M<<16,E=65535&(U=y),M=U>>>16,z=65535&(_=s),j=_>>>16,M+=(U=k)>>>16,z+=65535&(_=v),j+=_>>>16,K=n,P=o,Y=i,q=s=65535&(z+=(M+=(E+=65535&U)>>>16)>>>16)|(j+=z>>>16)<<16,L=l,O=c,R=u,T=h,C=f,F=d,I=p,Z=y=65535&E|M<<16,D=g,G=m,H=b,N=w,x%16==15)for(A=0;A<16;A++)_=S[A],E=65535&(U=B[A]),M=U>>>16,z=65535&_,j=_>>>16,_=S[(A+9)%16],E+=65535&(U=B[(A+9)%16]),M+=U>>>16,z+=65535&_,j+=_>>>16,v=S[(A+1)%16],E+=65535&(U=((k=B[(A+1)%16])>>>1|v<<31)^(k>>>8|v<<24)^(k>>>7|v<<25)),M+=U>>>16,z+=65535&(_=(v>>>1|k<<31)^(v>>>8|k<<24)^v>>>7),j+=_>>>16,v=S[(A+14)%16],M+=(U=((k=B[(A+14)%16])>>>19|v<<13)^(v>>>29|k<<3)^(k>>>6|v<<26))>>>16,z+=65535&(_=(v>>>19|k<<13)^(k>>>29|v<<3)^v>>>6),j+=_>>>16,j+=(z+=(M+=(E+=65535&U)>>>16)>>>16)>>>16,S[A]=65535&z|j<<16,B[A]=65535&E|M<<16;E=65535&(U=N),M=U>>>16,z=65535&(_=T),j=_>>>16,_=e[0],M+=(U=r[0])>>>16,z+=65535&_,j+=_>>>16,j+=(z+=(M+=(E+=65535&U)>>>16)>>>16)>>>16,e[0]=T=65535&z|j<<16,r[0]=N=65535&E|M<<16,E=65535&(U=C),M=U>>>16,z=65535&(_=K),j=_>>>16,_=e[1],M+=(U=r[1])>>>16,z+=65535&_,j+=_>>>16,j+=(z+=(M+=(E+=65535&U)>>>16)>>>16)>>>16,e[1]=K=65535&z|j<<16,r[1]=C=65535&E|M<<16,E=65535&(U=F),M=U>>>16,z=65535&(_=P),j=_>>>16,_=e[2],M+=(U=r[2])>>>16,z+=65535&_,j+=_>>>16,j+=(z+=(M+=(E+=65535&U)>>>16)>>>16)>>>16,e[2]=P=65535&z|j<<16,r[2]=F=65535&E|M<<16,E=65535&(U=I),M=U>>>16,z=65535&(_=Y),j=_>>>16,_=e[3],M+=(U=r[3])>>>16,z+=65535&_,j+=_>>>16,j+=(z+=(M+=(E+=65535&U)>>>16)>>>16)>>>16,e[3]=Y=65535&z|j<<16,r[3]=I=65535&E|M<<16,E=65535&(U=Z),M=U>>>16,z=65535&(_=q),j=_>>>16,_=e[4],M+=(U=r[4])>>>16,z+=65535&_,j+=_>>>16,j+=(z+=(M+=(E+=65535&U)>>>16)>>>16)>>>16,e[4]=q=65535&z|j<<16,r[4]=Z=65535&E|M<<16,E=65535&(U=D),M=U>>>16,z=65535&(_=L),j=_>>>16,_=e[5],M+=(U=r[5])>>>16,z+=65535&_,j+=_>>>16,j+=(z+=(M+=(E+=65535&U)>>>16)>>>16)>>>16,e[5]=L=65535&z|j<<16,r[5]=D=65535&E|M<<16,E=65535&(U=G),M=U>>>16,z=65535&(_=O),j=_>>>16,_=e[6],M+=(U=r[6])>>>16,z+=65535&_,j+=_>>>16,j+=(z+=(M+=(E+=65535&U)>>>16)>>>16)>>>16,e[6]=O=65535&z|j<<16,r[6]=G=65535&E|M<<16,E=65535&(U=H),M=U>>>16,z=65535&(_=R),j=_>>>16,_=e[7],M+=(U=r[7])>>>16,z+=65535&_,j+=_>>>16,j+=(z+=(M+=(E+=65535&U)>>>16)>>>16)>>>16,e[7]=R=65535&z|j<<16,r[7]=H=65535&E|M<<16,V+=128,a-=128}return a}function $(e,r,t){var a,n=new Int32Array(8),o=new Int32Array(8),i=new Uint8Array(256),s=t;for(n[0]=1779033703,n[1]=3144134277,n[2]=1013904242,n[3]=2773480762,n[4]=1359893119,n[5]=2600822924,n[6]=528734635,n[7]=1541459225,o[0]=4089235720,o[1]=2227873595,o[2]=4271175723,o[3]=1595750129,o[4]=2917565137,o[5]=725511199,o[6]=4215389547,o[7]=327033209,X(n,o,r,t),t%=128,a=0;a<t;a++)i[a]=r[s-t+a];for(i[t]=128,i[(t=256-128*(t<112?1:0))-9]=0,p(i,t-8,s/536870912|0,s<<3),X(n,o,i,t),a=0;a<8;a++)p(e,8*a,n[a],o[a]);return 0}function J(e,t){var a=r(),n=r(),o=r(),i=r(),s=r(),l=r(),c=r(),h=r(),f=r();O(a,e[1],e[0]),O(f,t[1],t[0]),R(a,a,f),L(n,e[0],e[1]),L(f,t[0],t[1]),R(n,n,f),R(o,e[3],t[3]),R(o,o,u),R(i,e[2],t[2]),L(i,i,i),O(s,n,a),O(l,i,o),L(c,i,o),L(h,n,a),R(e[0],s,l),R(e[1],h,c),R(e[2],c,l),R(e[3],s,h)}function Q(e,r,t){var a;for(a=0;a<4;a++)T(e[a],r[a],t)}function ee(e,t){var a=r(),n=r(),o=r();C(o,t[2]),R(a,t[0],o),R(n,t[1],o),K(e,n),e[31]^=Y(a)<<7}function re(e,r,t){var a,n;for(S(e[0],i),S(e[1],s),S(e[2],s),S(e[3],i),n=255;n>=0;--n)Q(e,r,a=t[n/8|0]>>(7&n)&1),J(r,e),J(e,e),Q(e,r,a)}function te(e,t){var a=[r(),r(),r(),r()];S(a[0],h),S(a[1],f),S(a[2],s),R(a[3],h,f),re(e,a,t)}function ae(e,t,n){var o,i=new Uint8Array(64),s=[r(),r(),r(),r()];for(n||a(t,32),$(i,t,32),i[0]&=248,i[31]&=127,i[31]|=64,te(s,i),ee(e,s),o=0;o<32;o++)t[o+32]=e[o];return 0}var ne=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function oe(e,r){var t,a,n,o;for(a=63;a>=32;--a){for(t=0,n=a-32,o=a-12;n<o;++n)r[n]+=t-16*r[a]*ne[n-(a-32)],t=Math.floor((r[n]+128)/256),r[n]-=256*t;r[n]+=t,r[a]=0}for(t=0,n=0;n<32;n++)r[n]+=t-(r[31]>>4)*ne[n],t=r[n]>>8,r[n]&=255;for(n=0;n<32;n++)r[n]-=t*ne[n];for(a=0;a<32;a++)r[a+1]+=r[a]>>8,e[a]=255&r[a]}function ie(e){var r,t=new Float64Array(64);for(r=0;r<64;r++)t[r]=e[r];for(r=0;r<64;r++)e[r]=0;oe(e,t)}function se(e,t,a,n){var o,i,s=new Uint8Array(64),l=new Uint8Array(64),c=new Uint8Array(64),u=new Float64Array(64),h=[r(),r(),r(),r()];$(s,n,32),s[0]&=248,s[31]&=127,s[31]|=64;var f=a+64;for(o=0;o<a;o++)e[64+o]=t[o];for(o=0;o<32;o++)e[32+o]=s[32+o];for($(c,e.subarray(32),a+32),ie(c),te(h,c),ee(e,h),o=32;o<64;o++)e[o]=n[o];for($(l,e,a+64),ie(l),o=0;o<64;o++)u[o]=0;for(o=0;o<32;o++)u[o]=c[o];for(o=0;o<32;o++)for(i=0;i<32;i++)u[o+i]+=l[o]*s[i];return oe(e.subarray(32),u),f}function le(e,t,a,n){var o,l=new Uint8Array(32),u=new Uint8Array(64),h=[r(),r(),r(),r()],f=[r(),r(),r(),r()];if(a<64)return-1;if(function(e,t){var a=r(),n=r(),o=r(),l=r(),u=r(),h=r(),f=r();return S(e[2],s),q(e[1],t),N(o,e[1]),R(l,o,c),O(o,o,e[2]),L(l,e[2],l),N(u,l),N(h,u),R(f,h,u),R(a,f,o),R(a,a,l),F(a,a),R(a,a,o),R(a,a,l),R(a,a,l),R(e[0],a,l),N(n,e[0]),R(n,n,l),P(n,o)&&R(e[0],e[0],d),N(n,e[0]),R(n,n,l),P(n,o)?-1:(Y(e[0])===t[31]>>7&&O(e[0],i,e[0]),R(e[3],e[0],e[1]),0)}(f,n))return-1;for(o=0;o<a;o++)e[o]=t[o];for(o=0;o<32;o++)e[o+32]=n[o];if($(u,e,a),ie(u),re(h,f,u),te(f,t.subarray(32)),J(h,f),ee(l,h),a-=64,m(t,0,l,0)){for(o=0;o<a;o++)e[o]=0;return-1}for(o=0;o<a;o++)e[o]=t[o+64];return a}var ce,ue=64,he=32,fe=64;function de(e,r){if(32!==e.length)throw new Error("bad key size");if(24!==r.length)throw new Error("bad nonce size")}function pe(){for(var e=0;e<arguments.length;e++)if(!(arguments[e]instanceof Uint8Array))throw new TypeError("unexpected type, use Uint8Array")}function ye(e){for(var r=0;r<e.length;r++)e[r]=0}e.lowlevel={crypto_core_hsalsa20:w,crypto_stream_xor:_,crypto_stream:A,crypto_stream_salsa20_xor:k,crypto_stream_salsa20:x,crypto_onetimeauth:E,crypto_onetimeauth_verify:M,crypto_verify_16:g,crypto_verify_32:m,crypto_secretbox:z,crypto_secretbox_open:j,crypto_scalarmult:I,crypto_scalarmult_base:Z,crypto_box_beforenm:G,crypto_box_afternm:H,crypto_box:function(e,r,t,a,n,o){var i=new Uint8Array(32);return G(i,n,o),H(e,r,t,a,i)},crypto_box_open:function(e,r,t,a,n,o){var i=new Uint8Array(32);return G(i,n,o),V(e,r,t,a,i)},crypto_box_keypair:D,crypto_hash:$,crypto_sign:se,crypto_sign_keypair:ae,crypto_sign_open:le,crypto_secretbox_KEYBYTES:32,crypto_secretbox_NONCEBYTES:24,crypto_secretbox_ZEROBYTES:32,crypto_secretbox_BOXZEROBYTES:16,crypto_scalarmult_BYTES:32,crypto_scalarmult_SCALARBYTES:32,crypto_box_PUBLICKEYBYTES:32,crypto_box_SECRETKEYBYTES:32,crypto_box_BEFORENMBYTES:32,crypto_box_NONCEBYTES:24,crypto_box_ZEROBYTES:32,crypto_box_BOXZEROBYTES:16,crypto_sign_BYTES:ue,crypto_sign_PUBLICKEYBYTES:he,crypto_sign_SECRETKEYBYTES:fe,crypto_sign_SEEDBYTES:32,crypto_hash_BYTES:64,gf:r,D:c,L:ne,pack25519:K,unpack25519:q,M:R,A:L,S:N,Z:O,pow2523:F,add:J,set25519:S,modL:oe,scalarmult:re,scalarbase:te},e.randomBytes=function(e){var r=new Uint8Array(e);return a(r,e),r},e.secretbox=function(e,r,t){pe(e,r,t),de(t,r);for(var a=new Uint8Array(32+e.length),n=new Uint8Array(a.length),o=0;o<e.length;o++)a[o+32]=e[o];return z(n,a,a.length,r,t),n.subarray(16)},e.secretbox.open=function(e,r,t){pe(e,r,t),de(t,r);for(var a=new Uint8Array(16+e.length),n=new Uint8Array(a.length),o=0;o<e.length;o++)a[o+16]=e[o];return a.length<32||0!==j(n,a,a.length,r,t)?null:n.subarray(32)},e.secretbox.keyLength=32,e.secretbox.nonceLength=24,e.secretbox.overheadLength=16,e.scalarMult=function(e,r){if(pe(e,r),32!==e.length)throw new Error("bad n size");if(32!==r.length)throw new Error("bad p size");var t=new Uint8Array(32);return I(t,e,r),t},e.scalarMult.base=function(e){if(pe(e),32!==e.length)throw new Error("bad n size");var r=new Uint8Array(32);return Z(r,e),r},e.scalarMult.scalarLength=32,e.scalarMult.groupElementLength=32,e.box=function(r,t,a,n){var o=e.box.before(a,n);return e.secretbox(r,t,o)},e.box.before=function(e,r){pe(e,r),function(e,r){if(32!==e.length)throw new Error("bad public key size");if(32!==r.length)throw new Error("bad secret key size")}(e,r);var t=new Uint8Array(32);return G(t,e,r),t},e.box.after=e.secretbox,e.box.open=function(r,t,a,n){var o=e.box.before(a,n);return e.secretbox.open(r,t,o)},e.box.open.after=e.secretbox.open,e.box.keyPair=function(){var e=new Uint8Array(32),r=new Uint8Array(32);return D(e,r),{publicKey:e,secretKey:r}},e.box.keyPair.fromSecretKey=function(e){if(pe(e),32!==e.length)throw new Error("bad secret key size");var r=new Uint8Array(32);return Z(r,e),{publicKey:r,secretKey:new Uint8Array(e)}},e.box.publicKeyLength=32,e.box.secretKeyLength=32,e.box.sharedKeyLength=32,e.box.nonceLength=24,e.box.overheadLength=e.secretbox.overheadLength,e.sign=function(e,r){if(pe(e,r),r.length!==fe)throw new Error("bad secret key size");var t=new Uint8Array(ue+e.length);return se(t,e,e.length,r),t},e.sign.open=function(e,r){if(pe(e,r),r.length!==he)throw new Error("bad public key size");var t=new Uint8Array(e.length),a=le(t,e,e.length,r);if(a<0)return null;for(var n=new Uint8Array(a),o=0;o<n.length;o++)n[o]=t[o];return n},e.sign.detached=function(r,t){for(var a=e.sign(r,t),n=new Uint8Array(ue),o=0;o<n.length;o++)n[o]=a[o];return n},e.sign.detached.verify=function(e,r,t){if(pe(e,r,t),r.length!==ue)throw new Error("bad signature size");if(t.length!==he)throw new Error("bad public key size");var a,n=new Uint8Array(ue+e.length),o=new Uint8Array(ue+e.length);for(a=0;a<ue;a++)n[a]=r[a];for(a=0;a<e.length;a++)n[a+ue]=e[a];return le(o,n,n.length,t)>=0},e.sign.keyPair=function(){var e=new Uint8Array(he),r=new Uint8Array(fe);return ae(e,r),{publicKey:e,secretKey:r}},e.sign.keyPair.fromSecretKey=function(e){if(pe(e),e.length!==fe)throw new Error("bad secret key size");for(var r=new Uint8Array(he),t=0;t<r.length;t++)r[t]=e[32+t];return{publicKey:r,secretKey:new Uint8Array(e)}},e.sign.keyPair.fromSeed=function(e){if(pe(e),32!==e.length)throw new Error("bad seed size");for(var r=new Uint8Array(he),t=new Uint8Array(fe),a=0;a<32;a++)t[a]=e[a];return ae(r,t,!0),{publicKey:r,secretKey:t}},e.sign.publicKeyLength=he,e.sign.secretKeyLength=fe,e.sign.seedLength=32,e.sign.signatureLength=ue,e.hash=function(e){pe(e);var r=new Uint8Array(64);return $(r,e,e.length),r},e.hash.hashLength=64,e.verify=function(e,r){return pe(e,r),0!==e.length&&0!==r.length&&e.length===r.length&&0===y(e,0,r,0,e.length)},e.setPRNG=function(e){a=e},(ce="undefined"!=typeof self?self.crypto||self.msCrypto:null)&&ce.getRandomValues?e.setPRNG((function(e,r){var t,a=new Uint8Array(r);for(t=0;t<r;t+=65536)ce.getRandomValues(a.subarray(t,t+Math.min(r-t,65536)));for(t=0;t<r;t++)e[t]=a[t];ye(a)})):(ce=t(24))&&ce.randomBytes&&e.setPRNG((function(e,r){var t,a=ce.randomBytes(r);for(t=0;t<r;t++)e[t]=a[t];ye(a)}))}(e.exports?e.exports:self.nacl=self.nacl||{})},24:()=>{}},r={};function t(a){var n=r[a];if(void 0!==n)return n.exports;var o=r[a]={exports:{}};return e[a](o,o.exports,t),o.exports}t.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return t.d(r,{a:r}),r},t.d=(e,r)=>{for(var a in r)t.o(r,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:r[a]})},t.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),t.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var a={};return(()=>{"use strict";t.r(a),t.d(a,{KeyPair:()=>e.KeyPair,generateMnemonic:()=>h,isPasswordNeeded:()=>u,mnemonicToKeyPair:()=>y,mnemonicToSeed:()=>p,validateMnemonic:()=>g,wordlists:()=>r});var e={};t.r(e),t.d(e,{I:()=>y});var r={};t.r(r),t.d(r,{EN:()=>o,default:()=>o,english:()=>o});const n=self.crypto,o=["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"];async function i(e){return 0==(await l(e,"TON seed version",Math.max(1,Math.floor(390.625))))[0]}async function s(e,r=""){const t=e.join(" ");return await async function(e,r){const t=c(e).buffer,a=r.length?c(r).buffer:new ArrayBuffer(0),o={name:"HMAC",hash:"SHA-512"},i=await n.subtle.importKey("raw",t,o,!1,["sign"]);return await n.subtle.sign(o,i,a)}(t,r)}async function l(e,r,t){const a=c(r).buffer,o=await n.subtle.importKey("raw",e,{name:"PBKDF2"},!1,["deriveBits"]),i=await n.subtle.deriveBits({name:"PBKDF2",hash:"SHA-512",salt:a,iterations:t},o,512);return new Uint8Array(i)}function c(e,r=1){let t,a;switch(r){case 1:t=new ArrayBuffer(e.length),a=new Uint8Array(t);break;case 2:t=new ArrayBuffer(2*e.length),a=new Uint16Array(t);break;case 4:t=new ArrayBuffer(4*e.length),a=new Uint32Array(t);break;default:throw new Error(`Incorrect size specified: ${r}`)}for(let r=0,t=e.length;r<t;r++)a[r]=e.charCodeAt(r);return new Uint8Array(a.buffer)}async function u(e){const r=await s(e,"");return await async function(e){return 1==(await l(e,"TON fast seed version",1))[0]}(r)&&!await i(r)}async function h(e=24,r="",t=o){let a=0,l=[];for(;;){a+=1,l=[];const o=n.getRandomValues(new Uint16Array(e));for(let r=0;r<e;r++)l.push(t[2047&o[r]]);if((!(r.length>0)||await u(l))&&await i(await s(l,r)))break}return l}var f=t(780),d=t.n(f);async function p(e,r=""){const t=await s(e,r);return(await l(t,"TON default seed",1e5)).slice(0,32)}async function y(e,r=""){const t=await p(e,r);return d().sign.keyPair.fromSeed(t)}async function g(e,r="",t=o){for(let r of e)if(-1===t.indexOf(r))return!1;return!(r.length>0&&!await u(e))&&await i(await s(e,r))}})(),a})()}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/tweetnacl-util/nacl-util.js":
/*!**************************************************!*\
  !*** ./node_modules/tweetnacl-util/nacl-util.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "?44dc")["Buffer"];
// Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
(function(root, f) {
  'use strict';
  if ( true && module.exports) module.exports = f();
  else if (root.nacl) root.nacl.util = f();
  else {
    root.nacl = {};
    root.nacl.util = f();
  }
}(this, function() {
  'use strict';

  var util = {};

  function validateBase64(s) {
    if (!(/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s))) {
      throw new TypeError('invalid encoding');
    }
  }

  util.decodeUTF8 = function(s) {
    if (typeof s !== 'string') throw new TypeError('expected string');
    var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
    return b;
  };

  util.encodeUTF8 = function(arr) {
    var i, s = [];
    for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
    return decodeURIComponent(escape(s.join('')));
  };

  if (typeof atob === 'undefined') {
    // Node.js

    if (typeof Buffer.from !== 'undefined') {
       // Node v6 and later
      util.encodeBase64 = function (arr) { // v6 and later
          return Buffer.from(arr).toString('base64');
      };

      util.decodeBase64 = function (s) {
        validateBase64(s);
        return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0));
      };

    } else {
      // Node earlier than v6
      util.encodeBase64 = function (arr) { // v6 and later
        return (new Buffer(arr)).toString('base64');
      };

      util.decodeBase64 = function(s) {
        validateBase64(s);
        return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));
      };
    }

  } else {
    // Browsers

    util.encodeBase64 = function(arr) {
      var i, s = [], len = arr.length;
      for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
      return btoa(s.join(''));
    };

    util.decodeBase64 = function(s) {
      validateBase64(s);
      var i, d = atob(s), b = new Uint8Array(d.length);
      for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
      return b;
    };

  }

  return util;

}));


/***/ }),

/***/ "./node_modules/@tonconnect/protocol/lib/esm/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@tonconnect/protocol/lib/esm/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHAIN: () => (/* binding */ CHAIN)
/* harmony export */ });
/* unused harmony exports Base64, CONNECT_EVENT_ERROR_CODES, CONNECT_ITEM_ERROR_CODES, DISCONNECT_ERROR_CODES, SEND_TRANSACTION_ERROR_CODES, SIGN_DATA_ERROR_CODES, SessionCrypto, concatUint8Arrays, hexToByteArray, isNode, splitToUint8Arrays, toHexString */
/* harmony import */ var tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tweetnacl-util */ "./node_modules/tweetnacl-util/nacl-util.js");
/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tweetnacl */ "./node_modules/tweetnacl/nacl-fast.js");



var CONNECT_EVENT_ERROR_CODES;
(function (CONNECT_EVENT_ERROR_CODES) {
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["MANIFEST_NOT_FOUND_ERROR"] = 2] = "MANIFEST_NOT_FOUND_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["MANIFEST_CONTENT_ERROR"] = 3] = "MANIFEST_CONTENT_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function (CONNECT_ITEM_ERROR_CODES) {
    CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));

var SEND_TRANSACTION_ERROR_CODES;
(function (SEND_TRANSACTION_ERROR_CODES) {
    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));

var SIGN_DATA_ERROR_CODES;
(function (SIGN_DATA_ERROR_CODES) {
    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));

var DISCONNECT_ERROR_CODES;
(function (DISCONNECT_ERROR_CODES) {
    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));

var CHAIN;
(function (CHAIN) {
    CHAIN["MAINNET"] = "-239";
    CHAIN["TESTNET"] = "-3";
})(CHAIN || (CHAIN = {}));

function encodeUint8Array(value, urlSafe) {
    const encoded = tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.encodeBase64(value);
    if (!urlSafe) {
        return encoded;
    }
    return encodeURIComponent(encoded);
}
function decodeToUint8Array(value, urlSafe) {
    if (urlSafe) {
        value = decodeURIComponent(value);
    }
    return tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.decodeBase64(value);
}
function encode(value, urlSafe = false) {
    let uint8Array;
    if (value instanceof Uint8Array) {
        uint8Array = value;
    }
    else {
        if (typeof value !== 'string') {
            value = JSON.stringify(value);
        }
        uint8Array = tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.decodeUTF8(value);
    }
    return encodeUint8Array(uint8Array, urlSafe);
}
function decode(value, urlSafe = false) {
    const decodedUint8Array = decodeToUint8Array(value, urlSafe);
    return {
        toString() {
            return tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.encodeUTF8(decodedUint8Array);
        },
        toObject() {
            try {
                return JSON.parse(tweetnacl_util__WEBPACK_IMPORTED_MODULE_0__.encodeUTF8(decodedUint8Array));
            }
            catch (e) {
                return null;
            }
        },
        toUint8Array() {
            return decodedUint8Array;
        }
    };
}
const Base64 = {
    encode,
    decode
};

function concatUint8Arrays(buffer1, buffer2) {
    const mergedArray = new Uint8Array(buffer1.length + buffer2.length);
    mergedArray.set(buffer1);
    mergedArray.set(buffer2, buffer1.length);
    return mergedArray;
}
function splitToUint8Arrays(array, index) {
    if (index >= array.length) {
        throw new Error('Index is out of buffer');
    }
    const subArray1 = array.slice(0, index);
    const subArray2 = array.slice(index);
    return [subArray1, subArray2];
}
function toHexString(byteArray) {
    let hexString = '';
    byteArray.forEach(byte => {
        hexString += ('0' + (byte & 0xff).toString(16)).slice(-2);
    });
    return hexString;
}
function hexToByteArray(hexString) {
    if (hexString.length % 2 !== 0) {
        throw new Error(`Cannot convert ${hexString} to bytesArray`);
    }
    const result = new Uint8Array(hexString.length / 2);
    for (let i = 0; i < hexString.length; i += 2) {
        result[i / 2] = parseInt(hexString.slice(i, i + 2), 16);
    }
    return result;
}

function isNode() {
    return (typeof process !== 'undefined' && process.versions != null && process.versions.node != null);
}

class SessionCrypto {
    constructor(keyPair) {
        this.nonceLength = 24;
        this.keyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();
        this.sessionId = toHexString(this.keyPair.publicKey);
    }
    createKeypair() {
        return tweetnacl__WEBPACK_IMPORTED_MODULE_1__.box.keyPair();
    }
    createKeypairFromString(keyPair) {
        return {
            publicKey: hexToByteArray(keyPair.publicKey),
            secretKey: hexToByteArray(keyPair.secretKey)
        };
    }
    createNonce() {
        return tweetnacl__WEBPACK_IMPORTED_MODULE_1__.randomBytes(this.nonceLength);
    }
    encrypt(message, receiverPublicKey) {
        const encodedMessage = new TextEncoder().encode(message);
        const nonce = this.createNonce();
        const encrypted = tweetnacl__WEBPACK_IMPORTED_MODULE_1__.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);
        return concatUint8Arrays(nonce, encrypted);
    }
    decrypt(message, senderPublicKey) {
        const [nonce, internalMessage] = splitToUint8Arrays(message, this.nonceLength);
        const decrypted = tweetnacl__WEBPACK_IMPORTED_MODULE_1__.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);
        if (!decrypted) {
            throw new Error(`Decryption error: \n message: ${message.toString()} \n sender pubkey: ${senderPublicKey.toString()} \n keypair pubkey: ${this.keyPair.publicKey.toString()} \n keypair secretkey: ${this.keyPair.secretKey.toString()}`);
        }
        return new TextDecoder().decode(decrypted);
    }
    stringifyKeypair() {
        return {
            publicKey: toHexString(this.keyPair.publicKey),
            secretKey: toHexString(this.keyPair.secretKey)
        };
    }
}


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/idb-keyval/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/idb-keyval/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   createStore: () => (/* binding */ createStore),
/* harmony export */   del: () => (/* binding */ del),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   getMany: () => (/* binding */ getMany),
/* harmony export */   keys: () => (/* binding */ keys),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setMany: () => (/* binding */ setMany)
/* harmony export */ });
/* unused harmony exports delMany, entries, promisifyRequest, update, values */
function promisifyRequest(request) {
    return new Promise((resolve, reject) => {
        // @ts-ignore - file size hacks
        request.oncomplete = request.onsuccess = () => resolve(request.result);
        // @ts-ignore - file size hacks
        request.onabort = request.onerror = () => reject(request.error);
    });
}
function createStore(dbName, storeName) {
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    const dbp = promisifyRequest(request);
    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
    if (!defaultGetStoreFunc) {
        defaultGetStoreFunc = createStore('keyval-store', 'keyval');
    }
    return defaultGetStoreFunc;
}
/**
 * Get a value by its key.
 *
 * @param key
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function get(key, customStore = defaultGetStore()) {
    return customStore('readonly', (store) => promisifyRequest(store.get(key)));
}
/**
 * Set a value with a key.
 *
 * @param key
 * @param value
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function set(key, value, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => {
        store.put(value, key);
        return promisifyRequest(store.transaction);
    });
}
/**
 * Set multiple values at once. This is faster than calling set() multiple times.
 * It's also atomic – if one of the pairs can't be added, none will be added.
 *
 * @param entries Array of entries, where each entry is an array of `[key, value]`.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function setMany(entries, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => {
        entries.forEach((entry) => store.put(entry[1], entry[0]));
        return promisifyRequest(store.transaction);
    });
}
/**
 * Get multiple values by their keys
 *
 * @param keys
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function getMany(keys, customStore = defaultGetStore()) {
    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));
}
/**
 * Update a value. This lets you see the old value and update it as an atomic operation.
 *
 * @param key
 * @param updater A callback that takes the old value and returns a new value.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function update(key, updater, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => 
    // Need to create the promise manually.
    // If I try to chain promises, the transaction closes in browsers
    // that use a promise polyfill (IE10/11).
    new Promise((resolve, reject) => {
        store.get(key).onsuccess = function () {
            try {
                store.put(updater(this.result), key);
                resolve(promisifyRequest(store.transaction));
            }
            catch (err) {
                reject(err);
            }
        };
    }));
}
/**
 * Delete a particular key from the store.
 *
 * @param key
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function del(key, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => {
        store.delete(key);
        return promisifyRequest(store.transaction);
    });
}
/**
 * Delete multiple keys at once.
 *
 * @param keys List of keys to delete.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function delMany(keys, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => {
        keys.forEach((key) => store.delete(key));
        return promisifyRequest(store.transaction);
    });
}
/**
 * Clear all values in the store.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function clear(customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => {
        store.clear();
        return promisifyRequest(store.transaction);
    });
}
function eachCursor(store, callback) {
    store.openCursor().onsuccess = function () {
        if (!this.result)
            return;
        callback(this.result);
        this.result.continue();
    };
    return promisifyRequest(store.transaction);
}
/**
 * Get all keys in the store.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function keys(customStore = defaultGetStore()) {
    return customStore('readonly', (store) => {
        // Fast path for modern browsers
        if (store.getAllKeys) {
            return promisifyRequest(store.getAllKeys());
        }
        const items = [];
        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
    });
}
/**
 * Get all values in the store.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function values(customStore = defaultGetStore()) {
    return customStore('readonly', (store) => {
        // Fast path for modern browsers
        if (store.getAll) {
            return promisifyRequest(store.getAll());
        }
        const items = [];
        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);
    });
}
/**
 * Get all entries in the store. Each entry is an array of `[key, value]`.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function entries(customStore = defaultGetStore()) {
    return customStore('readonly', (store) => {
        // Fast path for modern browsers
        // (although, hopefully we'll get a simpler path some day)
        if (store.getAll && store.getAllKeys) {
            return Promise.all([
                promisifyRequest(store.getAllKeys()),
                promisifyRequest(store.getAll()),
            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));
        }
        const items = [];
        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));
    });
}




/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_ton_core_dist_boc_BitReader_js-node_modules_ton_core_dist_dict_Dictionar-9afbaa.955f364579cad656bc8a.js.map